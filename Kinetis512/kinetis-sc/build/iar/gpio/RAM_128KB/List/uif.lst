###############################################################################
#                                                                             #
#                                                       04/Mar/2012  11:30:44 #
# IAR ANSI C/C++ Compiler V6.10.1.22143/W32 EVALUATION for ARM                #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\My Works\K60\Kinetis512\kinetis-sc\src\common\uif.c   #
#    Command line =  "F:\My Works\K60\Kinetis512\kinetis-sc\src\common\uif.c" #
#                     -D IAR -D TWR_K60N512 -lCN "F:\My                       #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\RAM_128KB #
#                    \List\" -lB "F:\My Works\K60\Kinetis512\kinetis-sc\build #
#                    \iar\gpio\RAM_128KB\List\" -o "F:\My                     #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\RAM_128KB #
#                    \Obj\" --no_cse --no_unroll --no_inline                  #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "D:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I "F:\My     #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\projects\gpio\" -I "F:\My                            #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\common\" -I "F:\My Works\K60\Kinetis512\kinetis-sc\b #
#                    uild\iar\gpio\..\..\..\src\cpu\" -I "F:\My               #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\cpu\headers\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\uart\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\mcg\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\wdog\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\platforms\" -I "F:\My Works\K60\Kinetis512\kinetis-s #
#                    c\build\iar\gpio\..\" -Ol --use_c++_inline               #
#    List file    =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\RAM #
#                    _128KB\List\uif.lst                                      #
#    Object file  =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\RAM #
#                    _128KB\Obj\uif.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

F:\My Works\K60\Kinetis512\kinetis-sc\src\common\uif.c
      1          /*
      2           * File:    uif.c
      3           * Purpose: Provide an interactive user interface
      4           *              
      5           * Notes:   The commands, set/show parameters, and prompt are configured 
      6           *          at the project level
      7           */
      8          
      9          #include "common.h"
     10          #include "uif.h"
     11          
     12          /********************************************************************/
     13          /*
     14           * Global messages -- constant strings
     15           */

   \                                 In section .text, align 4, keep-with-next
     16          const char HELPMSG[] =
   \                     HELPMSG:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   456E74657220       DC8 69, 110, 116, 101, 114, 32, 39, 104, 101, 108
   \              2768656C    
   \   0000000A   702720666F72       DC8 112, 39, 32, 102, 111, 114, 32, 104, 101, 108
   \              2068656C    
   \   00000014   702E0A00           DC8 112, 46, 10, 0
     17              "Enter 'help' for help.\n";
     18          

   \                                 In section .text, align 4, keep-with-next
     19          const char INVARG[] =
   \                     INVARG:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 73, 110, 118
   \              20496E76    
   \   0000000A   616C69642061       DC8 97, 108, 105, 100, 32, 97, 114, 103, 117, 109
   \              7267756D    
   \   00000014   656E743A2025       DC8 101, 110, 116, 58, 32, 37, 115, 10, 0, 0
   \              730A0000    
   \   0000001E   0000               DC8 0, 0
     20              "Error: Invalid argument: %s\n";
     21          

   \                                 In section .text, align 4, keep-with-next
     22          const char INVALUE[] = 
   \                     INVALUE:
   \   00000000                      ; Initializer data, 28 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 73, 110, 118
   \              20496E76    
   \   0000000A   616C69642076       DC8 97, 108, 105, 100, 32, 118, 97, 108, 117, 101
   \              616C7565    
   \   00000014   3A2025730A00       DC8 58, 32, 37, 115, 10, 0, 0, 0
   \              0000        
     23              "Error: Invalid value: %s\n";
     24          
     25          /*
     26           * Strings used by this file only
     27           */

   \                                 In section .text, align 4, keep-with-next
     28          static const char INVCMD[] =
   \                     INVCMD:
   \   00000000                      ; Initializer data, 28 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 78, 111, 32
   \              204E6F20    
   \   0000000A   737563682063       DC8 115, 117, 99, 104, 32, 99, 111, 109, 109, 97
   \              6F6D6D61    
   \   00000014   6E643A202573       DC8 110, 100, 58, 32, 37, 115, 10, 0
   \              0A00        
     29              "Error: No such command: %s\n";
     30          

   \                                 In section .text, align 4, keep-with-next
     31          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000                      ; Initializer data, 20 bytes
   \   00000000   253873202025       DC8 37, 56, 115, 32, 32, 37, 45, 50, 53, 115
   \              2D323573    
   \   0000000A   202573202573       DC8 32, 37, 115, 32, 37, 115, 10, 0, 0, 0
   \              0A000000    
     32              "%8s  %-25s %s %s\n";
     33          

   \                                 In section .text, align 4, keep-with-next
     34          static const char SYNTAX[] = 
   \                     SYNTAX:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 73, 110, 118
   \              20496E76    
   \   0000000A   616C69642073       DC8 97, 108, 105, 100, 32, 115, 121, 110, 116, 97
   \              796E7461    
   \   00000014   7820666F723A       DC8 120, 32, 102, 111, 114, 58, 32, 37, 115, 10
   \              2025730A    
   \   0000001E   0000               DC8 0, 0
     35              "Error: Invalid syntax for: %s\n";
     36          

   \                                 In section .text, align 4, keep-with-next
     37          static const char INVOPT[] = 
   \                     INVOPT:
   \   00000000                      ; Initializer data, 40 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 32, 73, 110
   \              2020496E    
   \   0000000A   76616C696420       DC8 118, 97, 108, 105, 100, 32, 115, 101, 116, 47
   \              7365742F    
   \   00000014   73686F77206F       DC8 115, 104, 111, 119, 32, 111, 112, 116, 105, 111
   \              7074696F    
   \   0000001E   6E3A2025730A       DC8 110, 58, 32, 37, 115, 10, 0, 0, 0, 0
   \              00000000    
     38              "Error:  Invalid set/show option: %s\n";
     39          

   \                                 In section .text, align 4, keep-with-next
     40          static const char OPTFMT[] = 
   \                     OPTFMT:
   \   00000000                      ; Initializer data, 8 bytes
   \   00000000   253132733A20       DC8 37, 49, 50, 115, 58, 32, 0, 0
   \              0000        
     41              "%12s: ";
     42          

   \                                 In section .bss, align 4
     43          static char cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     44          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     45          
     46          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     47          char *
     48          get_line (char *line)
     49          {
   \                     get_line:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
     50              int pos;
     51              int ch;
     52          
     53              pos = 0;
   \   00000004   0025               MOVS     R5,#+0
     54              ch = (int)in_char();
   \   00000006   ........           BL       in_char
   \   0000000A   0DE0               B.N      ??get_line_0
     55              while ( (ch != 0x0D /* CR */) &&
     56                      (ch != 0x0A /* LF/NL */) &&
     57                      (pos < UIF_MAX_LINE))
     58              {
     59                  switch (ch)
     60                  {
     61                      case 0x08:      /* Backspace */
     62                      case 0x7F:      /* Delete */
     63                          if (pos > 0)
     64                          {
     65                              pos -= 1;
     66                              out_char(0x08);    /* backspace */
     67                              out_char(' ');
     68                              out_char(0x08);    /* backspace */
     69                          }
     70                          break;
     71                      default:
     72                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1:
   \   0000000C   691C               ADDS     R1,R5,#+1
   \   0000000E   5029               CMP      R1,#+80
   \   00000010   08DA               BGE.N    ??get_line_2
     73                          {
     74                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000012   B0F12001           SUBS     R1,R0,#+32
   \   00000016   6029               CMP      R1,#+96
   \   00000018   04D2               BCS.N    ??get_line_2
     75                              {
     76                                  line[pos++] = (char)ch;
   \   0000001A   2855               STRB     R0,[R5, R4]
   \   0000001C   6D1C               ADDS     R5,R5,#+1
     77                                  out_char((char)ch);
   \   0000001E   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   ........           BL       out_char
     78                              }
     79                          }
     80                          break;
     81                  }
     82                  ch = (int)in_char();
   \                     ??get_line_2:
   \                     ??get_line_3:
   \   00000024   ........           BL       in_char
   \                     ??get_line_0:
   \   00000028   0D28               CMP      R0,#+13
   \   0000002A   15D0               BEQ.N    ??get_line_4
   \   0000002C   0A28               CMP      R0,#+10
   \   0000002E   13D0               BEQ.N    ??get_line_4
   \   00000030   502D               CMP      R5,#+80
   \   00000032   11DA               BGE.N    ??get_line_4
   \   00000034   0100               MOVS     R1,R0
   \   00000036   0829               CMP      R1,#+8
   \   00000038   01D0               BEQ.N    ??get_line_5
   \   0000003A   7F29               CMP      R1,#+127
   \   0000003C   E6D1               BNE.N    ??get_line_1
   \                     ??get_line_5:
   \   0000003E   012D               CMP      R5,#+1
   \   00000040   09DB               BLT.N    ??get_line_6
   \   00000042   6D1E               SUBS     R5,R5,#+1
   \   00000044   0820               MOVS     R0,#+8
   \   00000046   ........           BL       out_char
   \   0000004A   2020               MOVS     R0,#+32
   \   0000004C   ........           BL       out_char
   \   00000050   0820               MOVS     R0,#+8
   \   00000052   ........           BL       out_char
   \                     ??get_line_6:
   \   00000056   E5E7               B.N      ??get_line_3
     83              }
     84              line[pos] = '\0';
   \                     ??get_line_4:
   \   00000058   0020               MOVS     R0,#+0
   \   0000005A   2855               STRB     R0,[R5, R4]
     85              out_char(0x0D);    /* CR */
   \   0000005C   0D20               MOVS     R0,#+13
   \   0000005E   ........           BL       out_char
     86              out_char(0x0A);    /* LF */
   \   00000062   0A20               MOVS     R0,#+10
   \   00000064   ........           BL       out_char
     87          
     88              return line;
   \   00000068   2000               MOVS     R0,R4
   \   0000006A   32BD               POP      {R1,R4,R5,PC}    ;; return
     89          }
     90          
     91          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          int
     93          make_argv (char *cmdline, char *argv[])
     94          {
   \                     make_argv:
   \   00000000   30B4               PUSH     {R4,R5}
     95              int argc, i, in_text;
     96          
     97              /* 
     98               * Break cmdline into strings and argv
     99               * It is permissible for argv to be NULL, in which case
    100               * the purpose of this routine becomes to count args
    101               */
    102              argc = 0;
   \   00000002   0022               MOVS     R2,#+0
    103              i = 0;
   \   00000004   0023               MOVS     R3,#+0
    104              in_text = FALSE;
   \   00000006   0024               MOVS     R4,#+0
   \   00000008   05E0               B.N      ??make_argv_0
    105              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    106              {
    107                  if (((cmdline[i] == ' ')   ||
    108                       (cmdline[i] == '\t')) )
    109                  {
    110                      if (in_text)
   \                     ??make_argv_1:
   \   0000000A   002C               CMP      R4,#+0
   \   0000000C   02D0               BEQ.N    ??make_argv_2
    111                      {
    112                          /* end of command line argument */
    113                          cmdline[i] = '\0';
   \   0000000E   0024               MOVS     R4,#+0
   \   00000010   1C54               STRB     R4,[R3, R0]
    114                          in_text = FALSE;
   \   00000012   0024               MOVS     R4,#+0
    115                      }
    116                      else
    117                      {
    118                          /* still looking for next argument */
    119                          
    120                      }
    121                  }
    122                  else
    123                  {
    124                      /* got non-whitespace character */
    125                      if (in_text)
    126                      {
    127                      }
    128                      else
    129                      {
    130                          /* start of an argument */
    131                          in_text = TRUE;
    132                          if (argc < UIF_MAX_ARGS)
    133                          {
    134                              if (argv != NULL)
    135                                  argv[argc] = &cmdline[i];
    136                              argc++;
    137                          }
    138                          else
    139                              /*return argc;*/
    140                              break;
    141                      }
    142          
    143                  }
    144                  i++;    /* proceed to next character */
   \                     ??make_argv_2:
   \   00000014   5B1C               ADDS     R3,R3,#+1
   \                     ??make_argv_0:
   \   00000016   1D5C               LDRB     R5,[R3, R0]
   \   00000018   002D               CMP      R5,#+0
   \   0000001A   11D0               BEQ.N    ??make_argv_3
   \   0000001C   1D5C               LDRB     R5,[R3, R0]
   \   0000001E   202D               CMP      R5,#+32
   \   00000020   F3D0               BEQ.N    ??make_argv_1
   \   00000022   1D5C               LDRB     R5,[R3, R0]
   \   00000024   092D               CMP      R5,#+9
   \   00000026   F0D0               BEQ.N    ??make_argv_1
   \   00000028   002C               CMP      R4,#+0
   \   0000002A   F3D1               BNE.N    ??make_argv_2
   \   0000002C   0124               MOVS     R4,#+1
   \   0000002E   0A2A               CMP      R2,#+10
   \   00000030   06DA               BGE.N    ??make_argv_4
   \   00000032   0029               CMP      R1,#+0
   \   00000034   02D0               BEQ.N    ??make_argv_5
   \   00000036   1D18               ADDS     R5,R3,R0
   \   00000038   41F82250           STR      R5,[R1, R2, LSL #+2]
   \                     ??make_argv_5:
   \   0000003C   521C               ADDS     R2,R2,#+1
   \   0000003E   E9E7               B.N      ??make_argv_2
    145              }
    146              if (argv != NULL)
   \                     ??make_argv_4:
   \                     ??make_argv_3:
   \   00000040   0029               CMP      R1,#+0
   \   00000042   02D0               BEQ.N    ??make_argv_6
    147                  argv[argc] = NULL;
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   41F82200           STR      R0,[R1, R2, LSL #+2]
    148              return argc;
   \                     ??make_argv_6:
   \   0000004A   1000               MOVS     R0,R2
   \   0000004C   30BC               POP      {R4,R5}
   \   0000004E   7047               BX       LR               ;; return
    149          }
    150          
    151          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    152          void
    153          run_cmd (void)
    154          {
   \                     run_cmd:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
    155              /*
    156               * Global array of pointers to emulate C argc,argv interface
    157               */
    158              int argc;
    159              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    160          
    161              get_line(cmdline1);
   \   00000004   ....               LDR.N    R0,??DataTable16_3
   \   00000006   ........           BL       get_line
    162          
    163              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000A   00A9               ADD      R1,SP,#+0
   \   0000000C   ....               LDR.N    R0,??DataTable16_3
   \   0000000E   ........           BL       make_argv
   \   00000012   0400               MOVS     R4,R0
   \   00000014   002C               CMP      R4,#+0
   \   00000016   08D1               BNE.N    ??run_cmd_0
    164              {
    165                  /* no command entered, just a blank line */
    166                  strcpy(cmdline1,cmdline2);
   \   00000018   ....               LDR.N    R1,??DataTable16_4
   \   0000001A   ....               LDR.N    R0,??DataTable16_3
   \   0000001C   ........           BL       strcpy
    167                  argc = make_argv(cmdline1,argv);
   \   00000020   00A9               ADD      R1,SP,#+0
   \   00000022   ....               LDR.N    R0,??DataTable16_3
   \   00000024   ........           BL       make_argv
   \   00000028   0400               MOVS     R4,R0
    168              }
    169              cmdline2[0] = '\0';
   \                     ??run_cmd_0:
   \   0000002A   ....               LDR.N    R0,??DataTable16_4
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   0170               STRB     R1,[R0, #+0]
    170          
    171              if (argc)
   \   00000030   002C               CMP      R4,#+0
   \   00000032   43D0               BEQ.N    ??run_cmd_1
    172              {
    173                  int i;
    174                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0025               MOVS     R5,#+0
   \   00000036   00E0               B.N      ??run_cmd_2
   \                     ??run_cmd_3:
   \   00000038   6D1C               ADDS     R5,R5,#+1
   \                     ??run_cmd_2:
   \   0000003A   ....               LDR.N    R0,??DataTable16_5
   \   0000003C   0068               LDR      R0,[R0, #+0]
   \   0000003E   8542               CMP      R5,R0
   \   00000040   33DA               BGE.N    ??run_cmd_4
    175                  {
    176                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000042   0099               LDR      R1,[SP, #+0]
   \   00000044   1C20               MOVS     R0,#+28
   \   00000046   ....               LDR.N    R2,??DataTable16_6
   \   00000048   00FB0520           MLA      R0,R0,R5,R2
   \   0000004C   0068               LDR      R0,[R0, #+0]
   \   0000004E   ........           BL       strcasecmp
   \   00000052   0028               CMP      R0,#+0
   \   00000054   F0D1               BNE.N    ??run_cmd_3
    177                      {
    178                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    179                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000056   601E               SUBS     R0,R4,#+1
   \   00000058   1C21               MOVS     R1,#+28
   \   0000005A   ....               LDR.N    R2,??DataTable16_6
   \   0000005C   01FB0521           MLA      R1,R1,R5,R2
   \   00000060   4968               LDR      R1,[R1, #+4]
   \   00000062   8842               CMP      R0,R1
   \   00000064   1BDB               BLT.N    ??run_cmd_5
   \   00000066   1C20               MOVS     R0,#+28
   \   00000068   ....               LDR.N    R1,??DataTable16_6
   \   0000006A   00FB0510           MLA      R0,R0,R5,R1
   \   0000006E   8068               LDR      R0,[R0, #+8]
   \   00000070   611E               SUBS     R1,R4,#+1
   \   00000072   8842               CMP      R0,R1
   \   00000074   13DB               BLT.N    ??run_cmd_5
    180                          {
    181                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000076   1C20               MOVS     R0,#+28
   \   00000078   ....               LDR.N    R1,??DataTable16_6
   \   0000007A   00FB0510           MLA      R0,R0,R5,R1
   \   0000007E   007B               LDRB     R0,[R0, #+12]
   \   00000080   C007               LSLS     R0,R0,#+31
   \   00000082   03D5               BPL.N    ??run_cmd_6
    182                              {
    183                                  strcpy(cmdline2,argv[0]);
   \   00000084   0099               LDR      R1,[SP, #+0]
   \   00000086   ....               LDR.N    R0,??DataTable16_4
   \   00000088   ........           BL       strcpy
    184                              }
    185                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6:
   \   0000008C   00A9               ADD      R1,SP,#+0
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   1C22               MOVS     R2,#+28
   \   00000092   ....               LDR.N    R3,??DataTable16_6
   \   00000094   02FB0532           MLA      R2,R2,R5,R3
   \   00000098   1269               LDR      R2,[R2, #+16]
   \   0000009A   9047               BLX      R2
    186                              return;
   \   0000009C   0EE0               B.N      ??run_cmd_7
    187                          }
    188                          else
    189                          {
    190                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5:
   \   0000009E   0099               LDR      R1,[SP, #+0]
   \   000000A0   ........           ADR.W    R0,SYNTAX
   \   000000A4   ........           BL       printf
    191                              return;
   \   000000A8   08E0               B.N      ??run_cmd_7
    192                          }
    193                      }
    194                  }
    195                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4:
   \   000000AA   0099               LDR      R1,[SP, #+0]
   \   000000AC   ........           ADR.W    R0,INVCMD
   \   000000B0   ........           BL       printf
    196                  printf(HELPMSG);
   \   000000B4   ........           ADR.W    R0,HELPMSG
   \   000000B8   ........           BL       printf
    197              }
    198          }
   \                     ??run_cmd_1:
   \                     ??run_cmd_7:
   \   000000BC   0BB0               ADD      SP,SP,#+44
   \   000000BE   30BD               POP      {R4,R5,PC}       ;; return
    199          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    200          uint32
    201          get_value (char *s, int *success, int base)
    202          {
   \                     get_value:
   \   00000000   38B5               PUSH     {R3-R5,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    203              uint32 value;
    204              char *p;
    205          
    206              value = strtoul(s,&p,base);
   \   00000006   00A9               ADD      R1,SP,#+0
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   ........           BL       strtoul
    207              if ((value == 0) && (p == s))
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D1               BNE.N    ??get_value_0
   \   00000012   0099               LDR      R1,[SP, #+0]
   \   00000014   A142               CMP      R1,R4
   \   00000016   03D1               BNE.N    ??get_value_0
    208              {
    209                  *success = FALSE;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   2860               STR      R0,[R5, #+0]
    210                  return 0;
   \   0000001C   0020               MOVS     R0,#+0
   \   0000001E   01E0               B.N      ??get_value_1
    211              }
    212              else
    213              {
    214                  *success = TRUE;
   \                     ??get_value_0:
   \   00000020   0121               MOVS     R1,#+1
   \   00000022   2960               STR      R1,[R5, #+0]
    215                  return value;
   \                     ??get_value_1:
   \   00000024   32BD               POP      {R1,R4,R5,PC}    ;; return
    216              }
    217          }
    218          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    219          void
    220          uif_cmd_help (int argc, char **argv)
    221          {
   \                     uif_cmd_help:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    222              int index;
    223              
    224              (void)argc;
    225              (void)argv;
    226              
    227              printf("\n");
   \   00000004   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   00000006   ........           BL       printf
    228              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   19E0               B.N      ??uif_cmd_help_0
    229              {
    230                  printf(HELPFORMAT,
    231                      UIF_CMDTAB[index].cmd,
    232                      UIF_CMDTAB[index].description,
    233                      UIF_CMDTAB[index].cmd,
    234                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1:
   \   0000000E   1C20               MOVS     R0,#+28
   \   00000010   ....               LDR.N    R1,??DataTable16_6
   \   00000012   00FB0410           MLA      R0,R0,R4,R1
   \   00000016   8069               LDR      R0,[R0, #+24]
   \   00000018   0090               STR      R0,[SP, #+0]
   \   0000001A   1C20               MOVS     R0,#+28
   \   0000001C   ....               LDR.N    R1,??DataTable16_6
   \   0000001E   00FB0410           MLA      R0,R0,R4,R1
   \   00000022   0368               LDR      R3,[R0, #+0]
   \   00000024   1C20               MOVS     R0,#+28
   \   00000026   ....               LDR.N    R1,??DataTable16_6
   \   00000028   00FB0410           MLA      R0,R0,R4,R1
   \   0000002C   4269               LDR      R2,[R0, #+20]
   \   0000002E   1C20               MOVS     R0,#+28
   \   00000030   ....               LDR.N    R1,??DataTable16_6
   \   00000032   00FB0410           MLA      R0,R0,R4,R1
   \   00000036   0168               LDR      R1,[R0, #+0]
   \   00000038   ........           ADR.W    R0,HELPFORMAT
   \   0000003C   ........           BL       printf
    235              }
   \   00000040   641C               ADDS     R4,R4,#+1
   \                     ??uif_cmd_help_0:
   \   00000042   ....               LDR.N    R0,??DataTable16_5
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   8442               CMP      R4,R0
   \   00000048   E1DB               BLT.N    ??uif_cmd_help_1
    236              printf("\n");
   \   0000004A   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   0000004C   ........           BL       printf
    237          }
   \   00000050   13BD               POP      {R0,R1,R4,PC}    ;; return
    238          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    239          void
    240          uif_cmd_set (int argc, char **argv)
    241          {
   \                     uif_cmd_set:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
    242              int index;
    243          
    244              printf("\n");
   \   00000006   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   00000008   ........           BL       printf
    245              if (argc == 1)
   \   0000000C   012D               CMP      R5,#+1
   \   0000000E   1FD1               BNE.N    ??uif_cmd_set_0
    246              {
    247                  printf("Valid 'set' options:\n");
   \   00000010   ........           ADR.W    R0,`?<Constant "Valid \\'set\\' options:\\n">`
   \   00000014   ........           BL       printf
    248                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000018   0024               MOVS     R4,#+0
   \   0000001A   11E0               B.N      ??uif_cmd_set_1
    249                  {
    250                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2:
   \   0000001C   1420               MOVS     R0,#+20
   \   0000001E   ....               LDR.N    R1,??DataTable16_7
   \   00000020   00FB0410           MLA      R0,R0,R4,R1
   \   00000024   0168               LDR      R1,[R0, #+0]
   \   00000026   ........           ADR.W    R0,OPTFMT
   \   0000002A   ........           BL       printf
    251                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   0000002E   1420               MOVS     R0,#+20
   \   00000030   ....               LDR.N    R1,??DataTable16_7
   \   00000032   00FB0410           MLA      R0,R0,R4,R1
   \   00000036   0169               LDR      R1,[R0, #+16]
   \   00000038   ....               ADR.N    R0,??DataTable16_1  ;; "%s\n"
   \   0000003A   ........           BL       printf
    252                  }
   \   0000003E   641C               ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_1:
   \   00000040   ....               LDR.N    R0,??DataTable16_8
   \   00000042   0068               LDR      R0,[R0, #+0]
   \   00000044   8442               CMP      R4,R0
   \   00000046   E9DB               BLT.N    ??uif_cmd_set_2
    253                  printf("\n");
   \   00000048   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   0000004A   ........           BL       printf
    254                  return;
   \   0000004E   3BE0               B.N      ??uif_cmd_set_3
    255              }
    256          
    257              if (argc != 3)
   \                     ??uif_cmd_set_0:
   \   00000050   032D               CMP      R5,#+3
   \   00000052   04D0               BEQ.N    ??uif_cmd_set_4
    258              {
    259                  printf("Error: Invalid argument list\n");
   \   00000054   ........           ADR.W    R0,`?<Constant "Error: Invalid argume...">`
   \   00000058   ........           BL       printf
    260                  return;
   \   0000005C   34E0               B.N      ??uif_cmd_set_3
    261              }
    262          
    263              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4:
   \   0000005E   0024               MOVS     R4,#+0
   \   00000060   00E0               B.N      ??uif_cmd_set_5
   \                     ??uif_cmd_set_6:
   \   00000062   641C               ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_5:
   \   00000064   ....               LDR.N    R0,??DataTable16_8
   \   00000066   0068               LDR      R0,[R0, #+0]
   \   00000068   8442               CMP      R4,R0
   \   0000006A   28DA               BGE.N    ??uif_cmd_set_7
    264              {
    265                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   0000006C   7168               LDR      R1,[R6, #+4]
   \   0000006E   1420               MOVS     R0,#+20
   \   00000070   ....               LDR.N    R2,??DataTable16_7
   \   00000072   00FB0420           MLA      R0,R0,R4,R2
   \   00000076   0068               LDR      R0,[R0, #+0]
   \   00000078   ........           BL       strcasecmp
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   F0D1               BNE.N    ??uif_cmd_set_6
    266                  {
    267                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    268                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000080   A81E               SUBS     R0,R5,#+2
   \   00000082   1421               MOVS     R1,#+20
   \   00000084   ....               LDR.N    R2,??DataTable16_7
   \   00000086   01FB0421           MLA      R1,R1,R4,R2
   \   0000008A   4968               LDR      R1,[R1, #+4]
   \   0000008C   8842               CMP      R0,R1
   \   0000008E   10DB               BLT.N    ??uif_cmd_set_8
   \   00000090   1420               MOVS     R0,#+20
   \   00000092   ....               LDR.N    R1,??DataTable16_7
   \   00000094   00FB0410           MLA      R0,R0,R4,R1
   \   00000098   8068               LDR      R0,[R0, #+8]
   \   0000009A   A91E               SUBS     R1,R5,#+2
   \   0000009C   8842               CMP      R0,R1
   \   0000009E   08DB               BLT.N    ??uif_cmd_set_8
    269                      {
    270                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A0   3100               MOVS     R1,R6
   \   000000A2   2800               MOVS     R0,R5
   \   000000A4   1422               MOVS     R2,#+20
   \   000000A6   ....               LDR.N    R3,??DataTable16_7
   \   000000A8   02FB0432           MLA      R2,R2,R4,R3
   \   000000AC   D268               LDR      R2,[R2, #+12]
   \   000000AE   9047               BLX      R2
    271                          return;
   \   000000B0   0AE0               B.N      ??uif_cmd_set_3
    272                      }
    273                      else
    274                      {
    275                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8:
   \   000000B2   7168               LDR      R1,[R6, #+4]
   \   000000B4   ........           ADR.W    R0,INVARG
   \   000000B8   ........           BL       printf
    276                          return;
   \   000000BC   04E0               B.N      ??uif_cmd_set_3
    277                      }
    278                  }
    279              }
    280              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7:
   \   000000BE   7168               LDR      R1,[R6, #+4]
   \   000000C0   ........           ADR.W    R0,INVOPT
   \   000000C4   ........           BL       printf
    281          }
   \                     ??uif_cmd_set_3:
   \   000000C8   70BD               POP      {R4-R6,PC}       ;; return
    282          
    283          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    284          void
    285          uif_cmd_show (int argc, char **argv)
    286          {
   \                     uif_cmd_show:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0C00               MOVS     R4,R1
    287              int index;
    288          
    289              printf("\n");
   \   00000006   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   00000008   ........           BL       printf
    290              if (argc == 1)
   \   0000000C   012D               CMP      R5,#+1
   \   0000000E   21D1               BNE.N    ??uif_cmd_show_0
    291              {
    292                  /*
    293                   * Show all Option settings
    294                   */
    295                  argc = 2;
   \   00000010   0225               MOVS     R5,#+2
    296                  argv[2] = NULL;
   \   00000012   0020               MOVS     R0,#+0
   \   00000014   A060               STR      R0,[R4, #+8]
    297                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000016   0026               MOVS     R6,#+0
   \   00000018   14E0               B.N      ??uif_cmd_show_1
    298                  {
    299                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2:
   \   0000001A   1420               MOVS     R0,#+20
   \   0000001C   ....               LDR.N    R1,??DataTable16_7
   \   0000001E   00FB0610           MLA      R0,R0,R6,R1
   \   00000022   0168               LDR      R1,[R0, #+0]
   \   00000024   ........           ADR.W    R0,OPTFMT
   \   00000028   ........           BL       printf
    300                      UIF_SETCMDTAB[index].func(argc,argv);
   \   0000002C   2100               MOVS     R1,R4
   \   0000002E   2800               MOVS     R0,R5
   \   00000030   1422               MOVS     R2,#+20
   \   00000032   ....               LDR.N    R3,??DataTable16_7
   \   00000034   02FB0632           MLA      R2,R2,R6,R3
   \   00000038   D268               LDR      R2,[R2, #+12]
   \   0000003A   9047               BLX      R2
    301                      printf("\n");
   \   0000003C   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   0000003E   ........           BL       printf
    302                  }
   \   00000042   761C               ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_1:
   \   00000044   ....               LDR.N    R0,??DataTable16_8
   \   00000046   0068               LDR      R0,[R0, #+0]
   \   00000048   8642               CMP      R6,R0
   \   0000004A   E6DB               BLT.N    ??uif_cmd_show_2
    303                  printf("\n");
   \   0000004C   ....               ADR.N    R0,??DataTable16  ;; "\n"
   \   0000004E   ........           BL       printf
    304                  return;
   \   00000052   40E0               B.N      ??uif_cmd_show_3
    305              }
    306          
    307              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0:
   \   00000054   0026               MOVS     R6,#+0
   \   00000056   00E0               B.N      ??uif_cmd_show_4
   \                     ??uif_cmd_show_5:
   \   00000058   761C               ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_4:
   \   0000005A   ....               LDR.N    R0,??DataTable16_8
   \   0000005C   0068               LDR      R0,[R0, #+0]
   \   0000005E   8642               CMP      R6,R0
   \   00000060   34DA               BGE.N    ??uif_cmd_show_6
    308              {
    309                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000062   6168               LDR      R1,[R4, #+4]
   \   00000064   1420               MOVS     R0,#+20
   \   00000066   ....               LDR.N    R2,??DataTable16_7
   \   00000068   00FB0620           MLA      R0,R0,R6,R2
   \   0000006C   0068               LDR      R0,[R0, #+0]
   \   0000006E   ........           BL       strcasecmp
   \   00000072   0028               CMP      R0,#+0
   \   00000074   F0D1               BNE.N    ??uif_cmd_show_5
    310                  {
    311                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    312                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000076   A81E               SUBS     R0,R5,#+2
   \   00000078   1421               MOVS     R1,#+20
   \   0000007A   ....               LDR.N    R2,??DataTable16_7
   \   0000007C   01FB0621           MLA      R1,R1,R6,R2
   \   00000080   4968               LDR      R1,[R1, #+4]
   \   00000082   8842               CMP      R0,R1
   \   00000084   1CDB               BLT.N    ??uif_cmd_show_7
   \   00000086   1420               MOVS     R0,#+20
   \   00000088   ....               LDR.N    R1,??DataTable16_7
   \   0000008A   00FB0610           MLA      R0,R0,R6,R1
   \   0000008E   8068               LDR      R0,[R0, #+8]
   \   00000090   A91E               SUBS     R1,R5,#+2
   \   00000092   8842               CMP      R0,R1
   \   00000094   14DB               BLT.N    ??uif_cmd_show_7
    313                      {
    314                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000096   1420               MOVS     R0,#+20
   \   00000098   ....               LDR.N    R1,??DataTable16_7
   \   0000009A   00FB0610           MLA      R0,R0,R6,R1
   \   0000009E   0168               LDR      R1,[R0, #+0]
   \   000000A0   ........           ADR.W    R0,OPTFMT
   \   000000A4   ........           BL       printf
    315                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A8   2100               MOVS     R1,R4
   \   000000AA   2800               MOVS     R0,R5
   \   000000AC   1422               MOVS     R2,#+20
   \   000000AE   ....               LDR.N    R3,??DataTable16_7
   \   000000B0   02FB0632           MLA      R2,R2,R6,R3
   \   000000B4   D268               LDR      R2,[R2, #+12]
   \   000000B6   9047               BLX      R2
    316                          printf("\n\n");
   \   000000B8   ....               ADR.N    R0,??DataTable16_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000BA   ........           BL       printf
    317                          return;
   \   000000BE   0AE0               B.N      ??uif_cmd_show_3
    318                      }
    319                      else
    320                      {
    321                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7:
   \   000000C0   6168               LDR      R1,[R4, #+4]
   \   000000C2   ........           ADR.W    R0,INVARG
   \   000000C6   ........           BL       printf
    322                          return;
   \   000000CA   04E0               B.N      ??uif_cmd_show_3
    323                      }
    324                  }
    325              }
    326              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6:
   \   000000CC   6168               LDR      R1,[R4, #+4]
   \   000000CE   ........           ADR.W    R0,INVOPT
   \   000000D2   ........           BL       printf
    327          }
   \                     ??uif_cmd_show_3:
   \   000000D6   70BD               POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0A000000           DC8      "\n",0x0,0x0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   25730A00           DC8      "%s\n"

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0A0A0000           DC8      0x0A, 0x0A, 0x00, 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   ........           DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   ........           DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   ........           DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   ........           DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   ........           DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   ........           DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000                      ; Initializer data, 2 bytes
   \   00000000   0A00               DC8 10, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Valid \\'set\\' options:\\n">`:
   \   00000000                      ; Initializer data, 24 bytes
   \   00000000   56616C696420       DC8 86, 97, 108, 105, 100, 32, 39, 115, 101, 116
   \              27736574    
   \   0000000A   27206F707469       DC8 39, 32, 111, 112, 116, 105, 111, 110, 115, 58
   \              6F6E733A    
   \   00000014   0A000000           DC8 10, 0, 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s\\n">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   25730A00           DC8 37, 115, 10, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Error: Invalid argume...">`:
   \   00000000                      ; Initializer data, 32 bytes
   \   00000000   4572726F723A       DC8 69, 114, 114, 111, 114, 58, 32, 73, 110, 118
   \              20496E76    
   \   0000000A   616C69642061       DC8 97, 108, 105, 100, 32, 97, 114, 103, 117, 109
   \              7267756D    
   \   00000014   656E74206C69       DC8 101, 110, 116, 32, 108, 105, 115, 116, 10, 0
   \              73740A00    
   \   0000001E   0000               DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n\\n">`:
   \   00000000                      ; Initializer data, 4 bytes
   \   00000000   0A0A0000           DC8 10, 10, 0, 0
    328          
    329          /********************************************************************/

   Maximum stack usage in bytes:

     Function     .cstack
     --------     -------
     get_line         16
     get_value        16
     make_argv         8
     run_cmd          56
     uif_cmd_help     16
     uif_cmd_set      16
     uif_cmd_show     16


   Section sizes:

     Function/Label                         Bytes
     --------------                         -----
     HELPMSG                                  24
     INVARG                                   32
     INVALUE                                  28
     INVCMD                                   28
     HELPFORMAT                               20
     SYNTAX                                   32
     INVOPT                                   40
     OPTFMT                                    8
     cmdline1                                 80
     cmdline2                                 80
     get_line                                108
     make_argv                                80
     run_cmd                                 192
     get_value                                38
     uif_cmd_help                             82
     uif_cmd_set                             202
     uif_cmd_show                            216
     ??DataTable16                             4
     ??DataTable16_1                           4
     ??DataTable16_2                           4
     ??DataTable16_3                           4
     ??DataTable16_4                           4
     ??DataTable16_5                           4
     ??DataTable16_6                           4
     ??DataTable16_7                           4
     ??DataTable16_8                           4
     ?<Constant "\n">                          2
     ?<Constant "Valid \'set\' options:\n">   24
     ?<Constant "%s\n">                        4
     ?<Constant "Error: Invalid argume...">   32
     ?<Constant "\n\n">                        4

 
   160 bytes in section .bss
 1 232 bytes in section .text
 
 1 232 bytes of CODE memory
   160 bytes of DATA memory

Errors: none
Warnings: none
