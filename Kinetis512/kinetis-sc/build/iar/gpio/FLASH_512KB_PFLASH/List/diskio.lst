###############################################################################
#                                                                             #
#                                                       04/Mar/2012  17:39:52 #
# IAR ANSI C/C++ Compiler V6.10.1.22143/W32 EVALUATION for ARM                #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\My Works\K60\Kinetis512\kinetis-sc\src\projects\gpio\ #
#                    diskio.c                                                 #
#    Command line =  "F:\My Works\K60\Kinetis512\kinetis-sc\src\projects\gpio #
#                    \diskio.c" -D IAR -D TWR_K60N512 -lCN "F:\My             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLASH_512 #
#                    KB_PFLASH\List\" -lB "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLASH_512 #
#                    KB_PFLASH\List\" -o "F:\My Works\K60\Kinetis512\kinetis- #
#                    sc\build\iar\gpio\FLASH_512KB_PFLASH\Obj\" --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I "F:\My     #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\projects\gpio\" -I "F:\My                            #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\common\" -I "F:\My Works\K60\Kinetis512\kinetis-sc\b #
#                    uild\iar\gpio\..\..\..\src\cpu\" -I "F:\My               #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\cpu\headers\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\uart\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\mcg\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\wdog\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\platforms\" -I "F:\My Works\K60\Kinetis512\kinetis-s #
#                    c\build\iar\gpio\..\" -Ol --use_c++_inline               #
#    List file    =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLA #
#                    SH_512KB_PFLASH\List\diskio.lst                          #
#    Object file  =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLA #
#                    SH_512KB_PFLASH\Obj\diskio.o                             #
#                                                                             #
#                                                                             #
###############################################################################

F:\My Works\K60\Kinetis512\kinetis-sc\src\projects\gpio\diskio.c
      1          //=========================================================================
      2          // 文件名称：diskio.h
      3          // 功能概要：diskio构件源文件
      4          // 版权所有: 苏州大学飞思卡尔嵌入式中心(sumcu.suda.edu.cn)
      5          // 版本更新:  2011-12-14     V1.0        diskio构件初始版本
      6          //           2011-12-20     V1.1        diskio构件优化修改
      7          //=========================================================================
      8          #include  "hw_sdhc.h"
      9          #include  "diskio.h"
     10          
     11          //SD卡状态属性访问器

   \                                 In section .data, align 1
     12          static volatile unsigned char Stat   = STA_NOINIT; //保存SD卡状态
   \                     Stat:
   \   00000000   01                 DC8 1

   \                                 In section .text, align 2, keep-with-next
     13          uint8 GetCardStat(void) { return Stat; }
   \                     GetCardStat:
   \   00000000   ........           LDR.W    R0,??DataTable7
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   7047               BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     14          void SetCardStat(uint8 state) { Stat = state; }
   \                     SetCardStat:
   \   00000000   ........           LDR.W    R1,??DataTable7
   \   00000004   0870               STRB     R0,[R1, #+0]
   \   00000006   7047               BX       LR               ;; return
     15          

   \                                 In section .bss, align 4
     16          static volatile unsigned int  Timer = 0; //读写时间
   \                     Timer:
   \   00000000                      DS8 4
     17          
     18          //=========================================================================
     19          //函数名称：disk_initialize
     20          //功能概要：初始化数据盘（只支持数据盘0） 
     21          //参数说明：drv:设备号
     22          //函数返回：RES_OK：成功；其它：失败
     23          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
     24          DRESULT disk_initialize (unsigned char drv)
     25          {
   \                     disk_initialize:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
     26              uint32  param, c_size, c_size_mult, read_bl_len;
     27              ESDHC_COMMAND_STRUCT  command;
     28              SDCARD_STRUCT_PTR     sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000004   ........           LDR.W    R4,??DataTable7_1
     29          
     30              //检查参数
     31              if (drv || (NULL == sdcard_ptr)) return RES_PARERR; //仅仅支持设备0
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   01D1               BNE.N    ??disk_initialize_0
   \   0000000E   002C               CMP      R4,#+0
   \   00000010   01D1               BNE.N    ??disk_initialize_1
   \                     ??disk_initialize_0:
   \   00000012   0420               MOVS     R0,#+4
   \   00000014   0CE1               B.N      ??disk_initialize_2
     32              //检查卡插入状态
     33              if (Stat & STA_NODISK) return RES_NOTRDY; //SD卡未插入
   \                     ??disk_initialize_1:
   \   00000016   ........           LDR.W    R0,??DataTable7
   \   0000001A   0078               LDRB     R0,[R0, #+0]
   \   0000001C   8007               LSLS     R0,R0,#+30
   \   0000001E   01D5               BPL.N    ??disk_initialize_3
   \   00000020   0320               MOVS     R0,#+3
   \   00000022   05E1               B.N      ??disk_initialize_2
     34          
     35              //初始化SD卡设备登记信息
     36              sdcard_ptr->BITS = ESDHC_BUS_WIDTH_4BIT;//设置位宽为4位
   \                     ??disk_initialize_3:
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   6060               STR      R0,[R4, #+4]
     37              sdcard_ptr->SD_TIMEOUT = 0;
   \   00000028   0020               MOVS     R0,#+0
   \   0000002A   A060               STR      R0,[R4, #+8]
     38              sdcard_ptr->NUM_BLOCKS = 0;
   \   0000002C   0020               MOVS     R0,#+0
   \   0000002E   E060               STR      R0,[R4, #+12]
     39              sdcard_ptr->ADDRESS    = 0;
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   6061               STR      R0,[R4, #+20]
     40              sdcard_ptr->SDHC       = FALSE;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   2074               STRB     R0,[R4, #+16]
     41              sdcard_ptr->VERSION2   = FALSE;
   \   00000038   0020               MOVS     R0,#+0
   \   0000003A   6074               STRB     R0,[R4, #+17]
     42          
     43              //检测并初始化SD卡
     44              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_INIT, NULL))
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   ........           BL       hw_sdhc_ioctl
   \   00000044   0028               CMP      R0,#+0
   \   00000046   01D0               BEQ.N    ??disk_initialize_4
     45                  return RES_ERROR;
   \   00000048   0120               MOVS     R0,#+1
   \   0000004A   F1E0               B.N      ??disk_initialize_2
     46          
     47              //获取SD卡类型
     48              param = 0;
   \                     ??disk_initialize_4:
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   0090               STR      R0,[SP, #+0]
     49              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_GET_CARD, &param))
   \   00000050   00A9               ADD      R1,SP,#+0
   \   00000052   0320               MOVS     R0,#+3
   \   00000054   ........           BL       hw_sdhc_ioctl
   \   00000058   0028               CMP      R0,#+0
   \   0000005A   01D0               BEQ.N    ??disk_initialize_5
     50                  return RES_ERROR;
   \   0000005C   0120               MOVS     R0,#+1
   \   0000005E   E7E0               B.N      ??disk_initialize_2
     51              if (    (ESDHC_CARD_SD == param) 
     52                   || (ESDHC_CARD_SDHC == param) 
     53                   || (ESDHC_CARD_SDCOMBO == param) 
     54                   || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_5:
   \   00000060   0098               LDR      R0,[SP, #+0]
   \   00000062   0228               CMP      R0,#+2
   \   00000064   08D0               BEQ.N    ??disk_initialize_6
   \   00000066   0098               LDR      R0,[SP, #+0]
   \   00000068   0328               CMP      R0,#+3
   \   0000006A   05D0               BEQ.N    ??disk_initialize_6
   \   0000006C   0098               LDR      R0,[SP, #+0]
   \   0000006E   0528               CMP      R0,#+5
   \   00000070   02D0               BEQ.N    ??disk_initialize_6
   \   00000072   0098               LDR      R0,[SP, #+0]
   \   00000074   0628               CMP      R0,#+6
   \   00000076   2FD1               BNE.N    ??disk_initialize_7
     55              {
     56                  if ((ESDHC_CARD_SDHC == param) || (ESDHC_CARD_SDHCCOMBO == param))
   \                     ??disk_initialize_6:
   \   00000078   0098               LDR      R0,[SP, #+0]
   \   0000007A   0328               CMP      R0,#+3
   \   0000007C   02D0               BEQ.N    ??disk_initialize_8
   \   0000007E   0098               LDR      R0,[SP, #+0]
   \   00000080   0628               CMP      R0,#+6
   \   00000082   01D1               BNE.N    ??disk_initialize_9
     57                  {
     58                      sdcard_ptr->SDHC = TRUE;
   \                     ??disk_initialize_8:
   \   00000084   0120               MOVS     R0,#+1
   \   00000086   2074               STRB     R0,[R4, #+16]
     59                  }
     60              }
     61              else
     62                  return RES_PARERR;
     63          
     64              //SD卡标识
     65              command.COMMAND  = ESDHC_CMD2;
   \                     ??disk_initialize_9:
   \   00000088   0220               MOVS     R0,#+2
   \   0000008A   8DF80400           STRB     R0,[SP, #+4]
     66              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000008E   0020               MOVS     R0,#+0
   \   00000090   8DF80500           STRB     R0,[SP, #+5]
     67              command.ARGUMENT = 0;
   \   00000094   0020               MOVS     R0,#+0
   \   00000096   0290               STR      R0,[SP, #+8]
     68              command.READ     = FALSE;
   \   00000098   0020               MOVS     R0,#+0
   \   0000009A   8DF80C00           STRB     R0,[SP, #+12]
     69              command.BLOCKS   = 0;
   \   0000009E   0020               MOVS     R0,#+0
   \   000000A0   0490               STR      R0,[SP, #+16]
     70              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000A2   01A9               ADD      R1,SP,#+4
   \   000000A4   0220               MOVS     R0,#+2
   \   000000A6   ........           BL       hw_sdhc_ioctl
   \   000000AA   0028               CMP      R0,#+0
   \   000000AC   16D1               BNE.N    ??disk_initialize_10
     71                  return RES_ERROR;
     72          
     73              //获取SD卡地址
     74              command.COMMAND  = ESDHC_CMD3;
   \   000000AE   0320               MOVS     R0,#+3
   \   000000B0   8DF80400           STRB     R0,[SP, #+4]
     75              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000B4   0020               MOVS     R0,#+0
   \   000000B6   8DF80500           STRB     R0,[SP, #+5]
     76              command.ARGUMENT = 0;
   \   000000BA   0020               MOVS     R0,#+0
   \   000000BC   0290               STR      R0,[SP, #+8]
     77              command.READ     = FALSE;
   \   000000BE   0020               MOVS     R0,#+0
   \   000000C0   8DF80C00           STRB     R0,[SP, #+12]
     78              command.BLOCKS   = 0;
   \   000000C4   0020               MOVS     R0,#+0
   \   000000C6   0490               STR      R0,[SP, #+16]
     79              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000C8   01A9               ADD      R1,SP,#+4
   \   000000CA   0220               MOVS     R0,#+2
   \   000000CC   ........           BL       hw_sdhc_ioctl
   \   000000D0   0028               CMP      R0,#+0
   \   000000D2   05D0               BEQ.N    ??disk_initialize_11
     80                  return RES_ERROR;
   \   000000D4   0120               MOVS     R0,#+1
   \   000000D6   ABE0               B.N      ??disk_initialize_2
   \                     ??disk_initialize_7:
   \   000000D8   0420               MOVS     R0,#+4
   \   000000DA   A9E0               B.N      ??disk_initialize_2
   \                     ??disk_initialize_10:
   \   000000DC   0120               MOVS     R0,#+1
   \   000000DE   A7E0               B.N      ??disk_initialize_2
     81              sdcard_ptr->ADDRESS = command.RESPONSE[0] & 0xFFFF0000;
   \                     ??disk_initialize_11:
   \   000000E0   0598               LDR      R0,[SP, #+20]
   \   000000E2   000C               LSRS     R0,R0,#+16
   \   000000E4   0004               LSLS     R0,R0,#+16
   \   000000E6   6061               STR      R0,[R4, #+20]
     82              
     83              //获取SD卡读写属性参数
     84              command.COMMAND  = ESDHC_CMD9;
   \   000000E8   0920               MOVS     R0,#+9
   \   000000EA   8DF80400           STRB     R0,[SP, #+4]
     85              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000EE   0020               MOVS     R0,#+0
   \   000000F0   8DF80500           STRB     R0,[SP, #+5]
     86              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000F4   6069               LDR      R0,[R4, #+20]
   \   000000F6   0290               STR      R0,[SP, #+8]
     87              command.READ     = FALSE;
   \   000000F8   0020               MOVS     R0,#+0
   \   000000FA   8DF80C00           STRB     R0,[SP, #+12]
     88              command.BLOCKS   = 0;
   \   000000FE   0020               MOVS     R0,#+0
   \   00000100   0490               STR      R0,[SP, #+16]
     89              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000102   01A9               ADD      R1,SP,#+4
   \   00000104   0220               MOVS     R0,#+2
   \   00000106   ........           BL       hw_sdhc_ioctl
   \   0000010A   0028               CMP      R0,#+0
   \   0000010C   01D0               BEQ.N    ??disk_initialize_12
     90                  return RES_ERROR;
   \   0000010E   0120               MOVS     R0,#+1
   \   00000110   8EE0               B.N      ??disk_initialize_2
     91              if (0 == (command.RESPONSE[3] & 0x00C00000))
   \                     ??disk_initialize_12:
   \   00000112   0898               LDR      R0,[SP, #+32]
   \   00000114   10F4400F           TST      R0,#0xC00000
   \   00000118   19D1               BNE.N    ??disk_initialize_13
     92              {
     93                  read_bl_len = (command.RESPONSE[2] >> 8) & 0x0F;
   \   0000011A   0798               LDR      R0,[SP, #+28]
   \   0000011C   C0F30322           UBFX     R2,R0,#+8,#+4
     94                  c_size = command.RESPONSE[2] & 0x03;
   \   00000120   9DF81C00           LDRB     R0,[SP, #+28]
   \   00000124   10F00300           ANDS     R0,R0,#0x3
     95                  c_size = (c_size << 10) | (command.RESPONSE[1] >> 22);
   \   00000128   0699               LDR      R1,[SP, #+24]
   \   0000012A   890D               LSRS     R1,R1,#+22
   \   0000012C   51EA8020           ORRS     R0,R1,R0, LSL #+10
     96                  c_size_mult = (command.RESPONSE[1] >> 7) & 0x07;
   \   00000130   0699               LDR      R1,[SP, #+24]
   \   00000132   C1F3C211           UBFX     R1,R1,#+7,#+3
     97                  sdcard_ptr->NUM_BLOCKS = (c_size+1)*(1<<(c_size_mult+2))*(1<<(read_bl_len-9));
   \   00000136   401C               ADDS     R0,R0,#+1
   \   00000138   0123               MOVS     R3,#+1
   \   0000013A   891C               ADDS     R1,R1,#+2
   \   0000013C   13FA01F1           LSLS     R1,R3,R1
   \   00000140   4843               MULS     R0,R1,R0
   \   00000142   0121               MOVS     R1,#+1
   \   00000144   093A               SUBS     R2,R2,#+9
   \   00000146   9140               LSLS     R1,R1,R2
   \   00000148   4843               MULS     R0,R1,R0
   \   0000014A   E060               STR      R0,[R4, #+12]
   \   0000014C   07E0               B.N      ??disk_initialize_14
     98              }
     99              else
    100              {
    101                  sdcard_ptr->VERSION2 = TRUE;
   \                     ??disk_initialize_13:
   \   0000014E   0120               MOVS     R0,#+1
   \   00000150   6074               STRB     R0,[R4, #+17]
    102                  c_size = (command.RESPONSE[1] >> 8) & 0x003FFFFF;
   \   00000152   0698               LDR      R0,[SP, #+24]
   \   00000154   C0F31520           UBFX     R0,R0,#+8,#+22
    103                  sdcard_ptr->NUM_BLOCKS = (c_size + 1) << 10;
   \   00000158   401C               ADDS     R0,R0,#+1
   \   0000015A   8002               LSLS     R0,R0,#+10
   \   0000015C   E060               STR      R0,[R4, #+12]
    104              }
    105          
    106              //选择SD卡
    107              command.COMMAND  = ESDHC_CMD7;
   \                     ??disk_initialize_14:
   \   0000015E   0720               MOVS     R0,#+7
   \   00000160   8DF80400           STRB     R0,[SP, #+4]
    108              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000164   0020               MOVS     R0,#+0
   \   00000166   8DF80500           STRB     R0,[SP, #+5]
    109              command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000016A   6069               LDR      R0,[R4, #+20]
   \   0000016C   0290               STR      R0,[SP, #+8]
    110              command.READ     = FALSE;
   \   0000016E   0020               MOVS     R0,#+0
   \   00000170   8DF80C00           STRB     R0,[SP, #+12]
    111              command.BLOCKS   = 0;
   \   00000174   0020               MOVS     R0,#+0
   \   00000176   0490               STR      R0,[SP, #+16]
    112              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000178   01A9               ADD      R1,SP,#+4
   \   0000017A   0220               MOVS     R0,#+2
   \   0000017C   ........           BL       hw_sdhc_ioctl
   \   00000180   0028               CMP      R0,#+0
   \   00000182   01D0               BEQ.N    ??disk_initialize_15
    113                  return RES_ERROR;
   \   00000184   0120               MOVS     R0,#+1
   \   00000186   53E0               B.N      ??disk_initialize_2
    114          
    115              //设置块大小
    116              command.COMMAND  = ESDHC_CMD16;
   \                     ??disk_initialize_15:
   \   00000188   1020               MOVS     R0,#+16
   \   0000018A   8DF80400           STRB     R0,[SP, #+4]
    117              command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000018E   0020               MOVS     R0,#+0
   \   00000190   8DF80500           STRB     R0,[SP, #+5]
    118              command.ARGUMENT = IO_SDCARD_BLOCK_SIZE;
   \   00000194   4FF40070           MOV      R0,#+512
   \   00000198   0290               STR      R0,[SP, #+8]
    119              command.READ     = FALSE;
   \   0000019A   0020               MOVS     R0,#+0
   \   0000019C   8DF80C00           STRB     R0,[SP, #+12]
    120              command.BLOCKS   = 0;
   \   000001A0   0020               MOVS     R0,#+0
   \   000001A2   0490               STR      R0,[SP, #+16]
    121              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001A4   01A9               ADD      R1,SP,#+4
   \   000001A6   0220               MOVS     R0,#+2
   \   000001A8   ........           BL       hw_sdhc_ioctl
   \   000001AC   0028               CMP      R0,#+0
   \   000001AE   01D0               BEQ.N    ??disk_initialize_16
    122                  return RES_ERROR;
   \   000001B0   0120               MOVS     R0,#+1
   \   000001B2   3DE0               B.N      ??disk_initialize_2
    123          
    124              if (ESDHC_BUS_WIDTH_4BIT == sdcard_ptr->BITS)
   \                     ??disk_initialize_16:
   \   000001B4   6068               LDR      R0,[R4, #+4]
   \   000001B6   0128               CMP      R0,#+1
   \   000001B8   33D1               BNE.N    ??disk_initialize_17
    125              {
    126                  //发送特殊的命令CMD55
    127                  command.COMMAND  = ESDHC_CMD55;
   \   000001BA   3720               MOVS     R0,#+55
   \   000001BC   8DF80400           STRB     R0,[SP, #+4]
    128                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000001C0   0020               MOVS     R0,#+0
   \   000001C2   8DF80500           STRB     R0,[SP, #+5]
    129                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000001C6   6069               LDR      R0,[R4, #+20]
   \   000001C8   0290               STR      R0,[SP, #+8]
    130                  command.READ     = FALSE;
   \   000001CA   0020               MOVS     R0,#+0
   \   000001CC   8DF80C00           STRB     R0,[SP, #+12]
    131                  command.BLOCKS  = 0;
   \   000001D0   0020               MOVS     R0,#+0
   \   000001D2   0490               STR      R0,[SP, #+16]
    132                  if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001D4   01A9               ADD      R1,SP,#+4
   \   000001D6   0220               MOVS     R0,#+2
   \   000001D8   ........           BL       hw_sdhc_ioctl
   \   000001DC   0028               CMP      R0,#+0
   \   000001DE   01D0               BEQ.N    ??disk_initialize_18
    133                      return RES_ERROR;
   \   000001E0   0120               MOVS     R0,#+1
   \   000001E2   25E0               B.N      ??disk_initialize_2
    134          
    135                  //设置数据位宽为4位
    136                  command.COMMAND = ESDHC_ACMD6;
   \                     ??disk_initialize_18:
   \   000001E4   4620               MOVS     R0,#+70
   \   000001E6   8DF80400           STRB     R0,[SP, #+4]
    137                  command.TYPE = ESDHC_TYPE_NORMAL;
   \   000001EA   0020               MOVS     R0,#+0
   \   000001EC   8DF80500           STRB     R0,[SP, #+5]
    138                  command.ARGUMENT = 2;
   \   000001F0   0220               MOVS     R0,#+2
   \   000001F2   0290               STR      R0,[SP, #+8]
    139                  command.READ = FALSE;
   \   000001F4   0020               MOVS     R0,#+0
   \   000001F6   8DF80C00           STRB     R0,[SP, #+12]
    140                  command.BLOCKS = 0;
   \   000001FA   0020               MOVS     R0,#+0
   \   000001FC   0490               STR      R0,[SP, #+16]
    141                  if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000001FE   01A9               ADD      R1,SP,#+4
   \   00000200   0220               MOVS     R0,#+2
   \   00000202   ........           BL       hw_sdhc_ioctl
   \   00000206   0028               CMP      R0,#+0
   \   00000208   01D0               BEQ.N    ??disk_initialize_19
    142                      return RES_ERROR;
   \   0000020A   0120               MOVS     R0,#+1
   \   0000020C   10E0               B.N      ??disk_initialize_2
    143          
    144                  param = ESDHC_BUS_WIDTH_4BIT;
   \                     ??disk_initialize_19:
   \   0000020E   0120               MOVS     R0,#+1
   \   00000210   0090               STR      R0,[SP, #+0]
    145                  if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SET_BUS_WIDTH, &param))
   \   00000212   00A9               ADD      R1,SP,#+0
   \   00000214   0720               MOVS     R0,#+7
   \   00000216   ........           BL       hw_sdhc_ioctl
   \   0000021A   0028               CMP      R0,#+0
   \   0000021C   01D0               BEQ.N    ??disk_initialize_17
    146                      return RES_ERROR;
   \   0000021E   0120               MOVS     R0,#+1
   \   00000220   06E0               B.N      ??disk_initialize_2
    147              }
    148          
    149              Stat &= ~STA_NOINIT;//清除数据盘状态
   \                     ??disk_initialize_17:
   \   00000222   ....               LDR.N    R0,??DataTable7
   \   00000224   0078               LDRB     R0,[R0, #+0]
   \   00000226   10F0FE00           ANDS     R0,R0,#0xFE
   \   0000022A   ....               LDR.N    R1,??DataTable7
   \   0000022C   0870               STRB     R0,[R1, #+0]
    150              
    151              return RES_OK;
   \   0000022E   0020               MOVS     R0,#+0
   \                     ??disk_initialize_2:
   \   00000230   0AB0               ADD      SP,SP,#+40
   \   00000232   10BD               POP      {R4,PC}          ;; return
    152          }
    153          
    154          //=========================================================================
    155          //函数名称：disk_read                                                        
    156          //功能概要：读数据盘扇区                                                
    157          //参数说明：drv:设备号
    158          //         buff:用于存储读取的数据的缓存区
    159          //         sector:起始扇区号
    160          //         count:扇区数
    161          //函数返回：RES_OK：成功，其它：失败                                                              
    162          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    163          DRESULT disk_read(uint8 drv,uint8 *buff,uint32 sector, uint8 count)
    164          {
   \                     disk_read:
   \   00000000   30B5               PUSH     {R4,R5,LR}
   \   00000002   89B0               SUB      SP,SP,#+36
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1D00               MOVS     R5,R3
    165              ESDHC_COMMAND_STRUCT command;
    166              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   ....               LDR.N    R1,??DataTable7_1
    167          	
    168              //检查参数
    169              if (drv || !count) return RES_PARERR;
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   02D1               BNE.N    ??disk_read_0
   \   00000010   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   002D               CMP      R5,#+0
   \   00000014   01D1               BNE.N    ??disk_read_1
   \                     ??disk_read_0:
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   4FE0               B.N      ??disk_read_2
    170              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_read_1:
   \   0000001A   ....               LDR.N    R0,??DataTable7
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   C007               LSLS     R0,R0,#+31
   \   00000020   01D5               BPL.N    ??disk_read_3
   \   00000022   0320               MOVS     R0,#+3
   \   00000024   49E0               B.N      ??disk_read_2
    171              if ((NULL == buff)) return RES_ERROR;
   \                     ??disk_read_3:
   \   00000026   002C               CMP      R4,#+0
   \   00000028   01D1               BNE.N    ??disk_read_4
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   45E0               B.N      ??disk_read_2
    172          	
    173              if (!sdcard_ptr->SDHC)
   \                     ??disk_read_4:
   \   0000002E   087C               LDRB     R0,[R1, #+16]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   00D1               BNE.N    ??disk_read_5
    174                  //sector *= 512;//扇区号转化为起始地址
    175                  sector = sector << IO_SDCARD_BLOCK_SIZE_POWER;
   \   00000034   5202               LSLS     R2,R2,#+9
    176          
    177              if (count == 1)//读单个扇区
   \                     ??disk_read_5:
   \   00000036   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   012D               CMP      R5,#+1
   \   0000003A   1AD1               BNE.N    ??disk_read_6
    178              {
    179                  command.COMMAND  = ESDHC_CMD17;
   \   0000003C   1120               MOVS     R0,#+17
   \   0000003E   8DF80000           STRB     R0,[SP, #+0]
    180                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000042   0020               MOVS     R0,#+0
   \   00000044   8DF80100           STRB     R0,[SP, #+1]
    181                  command.ARGUMENT = sector;
   \   00000048   0192               STR      R2,[SP, #+4]
    182                  command.READ     = TRUE;
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   8DF80800           STRB     R0,[SP, #+8]
    183                  command.BLOCKS   = count;	
   \   00000050   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0395               STR      R5,[SP, #+12]
    184          
    185                  if (ESDHC_OK == hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000054   00A9               ADD      R1,SP,#+0
   \   00000056   0220               MOVS     R0,#+2
   \   00000058   ........           BL       hw_sdhc_ioctl
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   25D1               BNE.N    ??disk_read_7
    186                  {
    187                      //if (hw_sdhc_receive_block(buff, 512))
    188                      if (hw_sdhc_receive_block(buff, IO_SDCARD_BLOCK_SIZE))
   \   00000060   4FF40071           MOV      R1,#+512
   \   00000064   2000               MOVS     R0,R4
   \   00000066   ........           BL       hw_sdhc_receive_block
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   1ED0               BEQ.N    ??disk_read_7
    189                          count = 0;
   \   0000006E   0025               MOVS     R5,#+0
   \   00000070   1CE0               B.N      ??disk_read_7
    190                  }
    191              }
    192              else //读多个扇区
    193              {     
    194                  command.COMMAND  = ESDHC_CMD18;
   \                     ??disk_read_6:
   \   00000072   1220               MOVS     R0,#+18
   \   00000074   8DF80000           STRB     R0,[SP, #+0]
    195                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   8DF80100           STRB     R0,[SP, #+1]
    196                  command.ARGUMENT = sector;
   \   0000007E   0192               STR      R2,[SP, #+4]
    197                  command.READ     = TRUE;
   \   00000080   0120               MOVS     R0,#+1
   \   00000082   8DF80800           STRB     R0,[SP, #+8]
    198                  command.BLOCKS   = count;		
   \   00000086   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0395               STR      R5,[SP, #+12]
    199          
    200                  if (ESDHC_OK == hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   0000008A   00A9               ADD      R1,SP,#+0
   \   0000008C   0220               MOVS     R0,#+2
   \   0000008E   ........           BL       hw_sdhc_ioctl
   \   00000092   0028               CMP      R0,#+0
   \   00000094   0AD1               BNE.N    ??disk_read_7
    201                  {
    202                      if (hw_sdhc_receive_block(buff, IO_SDCARD_BLOCK_SIZE*count))
   \   00000096   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000098   4FF40070           MOV      R0,#+512
   \   0000009C   00FB05F1           MUL      R1,R0,R5
   \   000000A0   2000               MOVS     R0,R4
   \   000000A2   ........           BL       hw_sdhc_receive_block
   \   000000A6   0028               CMP      R0,#+0
   \   000000A8   00D0               BEQ.N    ??disk_read_7
    203                          count = 0;
   \   000000AA   0025               MOVS     R5,#+0
    204                  }
    205              }
    206          
    207              return count ? RES_ERROR : RES_OK;
   \                     ??disk_read_7:
   \   000000AC   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   002D               CMP      R5,#+0
   \   000000B0   01D0               BEQ.N    ??disk_read_8
   \   000000B2   0120               MOVS     R0,#+1
   \   000000B4   00E0               B.N      ??disk_read_9
   \                     ??disk_read_8:
   \   000000B6   0020               MOVS     R0,#+0
   \                     ??disk_read_9:
   \   000000B8   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_read_2:
   \   000000BA   09B0               ADD      SP,SP,#+36
   \   000000BC   30BD               POP      {R4,R5,PC}       ;; return
    208          }
    209          
    210          //=========================================================================
    211          //函数名称：disk_write                                                        
    212          //功能概要：写数据盘扇区                                                
    213          //参数说明：drv:设备号
    214          //         buff:待写入SD卡的数据的缓存区首地址
    215          //         sector:起始扇区号
    216          //         count:扇区数
    217          //函数返回：RES_OK：成功，其它：失败                                                              
    218          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    219          DRESULT disk_write(uint8 drv,const uint8 *buff,uint32 sector,uint8  count)
    220          {
   \                     disk_write:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1D00               MOVS     R5,R3
    221              ESDHC_COMMAND_STRUCT command;
    222              SDCARD_STRUCT_PTR    sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;
   \   00000008   ....               LDR.N    R4,??DataTable7_1
    223          
    224              //检查参数
    225              if (drv || !count) return RES_PARERR;
   \   0000000A   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   02D1               BNE.N    ??disk_write_0
   \   00000010   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   002D               CMP      R5,#+0
   \   00000014   01D1               BNE.N    ??disk_write_1
   \                     ??disk_write_0:
   \   00000016   0420               MOVS     R0,#+4
   \   00000018   76E0               B.N      ??disk_write_2
    226              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_write_1:
   \   0000001A   ....               LDR.N    R0,??DataTable7
   \   0000001C   0078               LDRB     R0,[R0, #+0]
   \   0000001E   C007               LSLS     R0,R0,#+31
   \   00000020   01D5               BPL.N    ??disk_write_3
   \   00000022   0320               MOVS     R0,#+3
   \   00000024   70E0               B.N      ??disk_write_2
    227              if (Stat & STA_PROTECT) return RES_WRPRT;
   \                     ??disk_write_3:
   \   00000026   ....               LDR.N    R0,??DataTable7
   \   00000028   0078               LDRB     R0,[R0, #+0]
   \   0000002A   4007               LSLS     R0,R0,#+29
   \   0000002C   01D5               BPL.N    ??disk_write_4
   \   0000002E   0220               MOVS     R0,#+2
   \   00000030   6AE0               B.N      ??disk_write_2
    228          
    229              //检测缓存区是否为空
    230              if ((NULL == buff)) return RES_ERROR;
   \                     ??disk_write_4:
   \   00000032   002E               CMP      R6,#+0
   \   00000034   01D1               BNE.N    ??disk_write_5
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   66E0               B.N      ??disk_write_2
    231          
    232          
    233              if (!sdcard_ptr->SDHC)
   \                     ??disk_write_5:
   \   0000003A   207C               LDRB     R0,[R4, #+16]
   \   0000003C   0028               CMP      R0,#+0
   \   0000003E   00D1               BNE.N    ??disk_write_6
    234                  //sector *= 512;	//扇区号转化为起始地址
    235                  sector = sector << IO_SDCARD_BLOCK_SIZE_POWER; 
   \   00000040   5202               LSLS     R2,R2,#+9
    236          
    237              if (count == 1)	//写单个扇区
   \                     ??disk_write_6:
   \   00000042   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   012D               CMP      R5,#+1
   \   00000046   1AD1               BNE.N    ??disk_write_7
    238              {
    239                  command.COMMAND  = ESDHC_CMD24;
   \   00000048   1820               MOVS     R0,#+24
   \   0000004A   8DF80000           STRB     R0,[SP, #+0]
    240                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   8DF80100           STRB     R0,[SP, #+1]
    241                  command.ARGUMENT = sector;
   \   00000054   0192               STR      R2,[SP, #+4]
    242                  command.READ = FALSE;
   \   00000056   0020               MOVS     R0,#+0
   \   00000058   8DF80800           STRB     R0,[SP, #+8]
    243                  command.BLOCKS = count;
   \   0000005C   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0395               STR      R5,[SP, #+12]
    244          
    245                  if (ESDHC_OK == hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000060   00A9               ADD      R1,SP,#+0
   \   00000062   0220               MOVS     R0,#+2
   \   00000064   ........           BL       hw_sdhc_ioctl
   \   00000068   0028               CMP      R0,#+0
   \   0000006A   25D1               BNE.N    ??disk_write_8
    246                  {
    247                      //if (hw_sdhc_send_block(buff,512))
    248                      if (hw_sdhc_send_block(buff, IO_SDCARD_BLOCK_SIZE))
   \   0000006C   4FF40071           MOV      R1,#+512
   \   00000070   3000               MOVS     R0,R6
   \   00000072   ........           BL       hw_sdhc_send_block
   \   00000076   0028               CMP      R0,#+0
   \   00000078   1ED0               BEQ.N    ??disk_write_8
    249                          count = 0;
   \   0000007A   0025               MOVS     R5,#+0
   \   0000007C   1CE0               B.N      ??disk_write_8
    250                  }
    251              }
    252              else //写多个扇区
    253              {
    254                  command.COMMAND  = ESDHC_CMD25;
   \                     ??disk_write_7:
   \   0000007E   1920               MOVS     R0,#+25
   \   00000080   8DF80000           STRB     R0,[SP, #+0]
    255                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   8DF80100           STRB     R0,[SP, #+1]
    256                  command.ARGUMENT = sector;
   \   0000008A   0192               STR      R2,[SP, #+4]
    257                  command.READ     = FALSE;
   \   0000008C   0020               MOVS     R0,#+0
   \   0000008E   8DF80800           STRB     R0,[SP, #+8]
    258                  command.BLOCKS   = count;
   \   00000092   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000094   0395               STR      R5,[SP, #+12]
    259          
    260                  if (ESDHC_OK == hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000096   00A9               ADD      R1,SP,#+0
   \   00000098   0220               MOVS     R0,#+2
   \   0000009A   ........           BL       hw_sdhc_ioctl
   \   0000009E   0028               CMP      R0,#+0
   \   000000A0   0AD1               BNE.N    ??disk_write_8
    261                  {
    262                      if (hw_sdhc_send_block(buff,IO_SDCARD_BLOCK_SIZE*count))
   \   000000A2   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A4   4FF40070           MOV      R0,#+512
   \   000000A8   00FB05F1           MUL      R1,R0,R5
   \   000000AC   3000               MOVS     R0,R6
   \   000000AE   ........           BL       hw_sdhc_send_block
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   00D0               BEQ.N    ??disk_write_8
    263                          count = 0;
   \   000000B6   0025               MOVS     R5,#+0
    264                  }
    265              }
    266          
    267              //等待完成
    268              do
    269              {
    270                  command.COMMAND  = ESDHC_CMD13;
   \                     ??disk_write_8:
   \   000000B8   0D20               MOVS     R0,#+13
   \   000000BA   8DF80000           STRB     R0,[SP, #+0]
    271                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   000000BE   0020               MOVS     R0,#+0
   \   000000C0   8DF80100           STRB     R0,[SP, #+1]
    272                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   000000C4   6069               LDR      R0,[R4, #+20]
   \   000000C6   0190               STR      R0,[SP, #+4]
    273                  command.READ     = FALSE;
   \   000000C8   0020               MOVS     R0,#+0
   \   000000CA   8DF80800           STRB     R0,[SP, #+8]
    274                  command.BLOCKS   = 0;
   \   000000CE   0020               MOVS     R0,#+0
   \   000000D0   0390               STR      R0,[SP, #+12]
    275              if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   000000D2   00A9               ADD      R1,SP,#+0
   \   000000D4   0220               MOVS     R0,#+2
   \   000000D6   ........           BL       hw_sdhc_ioctl
   \   000000DA   0028               CMP      R0,#+0
   \   000000DC   01D0               BEQ.N    ??disk_write_9
    276                  return RES_ERROR;
   \   000000DE   0120               MOVS     R0,#+1
   \   000000E0   12E0               B.N      ??disk_write_2
    277              
    278              if (command.RESPONSE[0] & 0xFFD98008)
   \                     ??disk_write_9:
   \   000000E2   0498               LDR      R0,[SP, #+16]
   \   000000E4   ....               LDR.N    R1,??DataTable7_2  ;; 0xffd98008
   \   000000E6   0842               TST      R0,R1
   \   000000E8   01D0               BEQ.N    ??disk_write_10
    279                  return RES_ERROR;
   \   000000EA   0120               MOVS     R0,#+1
   \   000000EC   0CE0               B.N      ??disk_write_2
    280          
    281              } while (0x000000900 != (command.RESPONSE[0] & 0x00001F00));		
   \                     ??disk_write_10:
   \   000000EE   0498               LDR      R0,[SP, #+16]
   \   000000F0   10F4F850           ANDS     R0,R0,#0x1F00
   \   000000F4   B0F5106F           CMP      R0,#+2304
   \   000000F8   DED1               BNE.N    ??disk_write_8
    282          
    283              return count ? RES_ERROR : RES_OK;
   \   000000FA   EDB2               UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FC   002D               CMP      R5,#+0
   \   000000FE   01D0               BEQ.N    ??disk_write_11
   \   00000100   0120               MOVS     R0,#+1
   \   00000102   00E0               B.N      ??disk_write_12
   \                     ??disk_write_11:
   \   00000104   0020               MOVS     R0,#+0
   \                     ??disk_write_12:
   \   00000106   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_write_2:
   \   00000108   08B0               ADD      SP,SP,#+32
   \   0000010A   70BD               POP      {R4-R6,PC}       ;; return
    284          }
    285          
    286          
    287          //=========================================================================
    288          //函数名称：disk_ioctl                                                        
    289          //功能概要：数据盘控制                                                
    290          //参数说明：drv:设备号
    291          //         ctrl:命令
    292          //         buff:数据的缓存区首地址
    293          //函数返回：RES_OK：成功，其它：失败                                                              
    294          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    295          DRESULT disk_ioctl(uint8 drv,uint8 ctrl,void  *buff)
    296          {
   \                     disk_ioctl:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
   \   00000004   1400               MOVS     R4,R2
    297              DRESULT 			 res;
    298              ESDHC_COMMAND_STRUCT command;
    299              SDCARD_STRUCT_PTR	 sdcard_ptr = (SDCARD_STRUCT_PTR)&SDHC_Card;	
   \   00000006   ....               LDR.N    R2,??DataTable7_1
    300              
    301              if (drv) return RES_PARERR;
   \   00000008   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   01D0               BEQ.N    ??disk_ioctl_0
   \   0000000E   0420               MOVS     R0,#+4
   \   00000010   51E0               B.N      ??disk_ioctl_1
    302              if (Stat & STA_NOINIT) return RES_NOTRDY;
   \                     ??disk_ioctl_0:
   \   00000012   ....               LDR.N    R0,??DataTable7
   \   00000014   0078               LDRB     R0,[R0, #+0]
   \   00000016   C007               LSLS     R0,R0,#+31
   \   00000018   01D5               BPL.N    ??disk_ioctl_2
   \   0000001A   0320               MOVS     R0,#+3
   \   0000001C   4BE0               B.N      ??disk_ioctl_1
    303              
    304              res = RES_ERROR;
   \                     ??disk_ioctl_2:
   \   0000001E   0120               MOVS     R0,#+1
    305              switch (ctrl) 
   \   00000020   C9B2               UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0029               CMP      R1,#+0
   \   00000024   08D0               BEQ.N    ??disk_ioctl_3
   \   00000026   0129               CMP      R1,#+1
   \   00000028   08D0               BEQ.N    ??disk_ioctl_4
   \   0000002A   0229               CMP      R1,#+2
   \   0000002C   0AD0               BEQ.N    ??disk_ioctl_5
   \   0000002E   0329               CMP      R1,#+3
   \   00000030   0DD0               BEQ.N    ??disk_ioctl_6
   \   00000032   0529               CMP      R1,#+5
   \   00000034   3CD0               BEQ.N    ??disk_ioctl_7
   \   00000036   3CE0               B.N      ??disk_ioctl_8
    306              {
    307              case CTRL_SYNC :
    308                  res = RES_OK;
   \                     ??disk_ioctl_3:
   \   00000038   0020               MOVS     R0,#+0
    309                  break;
   \   0000003A   3BE0               B.N      ??disk_ioctl_9
    310              case GET_SECTOR_COUNT :
    311                  *(unsigned long*)buff = sdcard_ptr->NUM_BLOCKS;
   \                     ??disk_ioctl_4:
   \   0000003C   D068               LDR      R0,[R2, #+12]
   \   0000003E   2060               STR      R0,[R4, #+0]
    312                  res = RES_OK;
   \   00000040   0020               MOVS     R0,#+0
    313                  break; 
   \   00000042   37E0               B.N      ??disk_ioctl_9
    314              case GET_SECTOR_SIZE :
    315                  *(unsigned short*)buff = IO_SDCARD_BLOCK_SIZE;
   \                     ??disk_ioctl_5:
   \   00000044   4FF40070           MOV      R0,#+512
   \   00000048   2080               STRH     R0,[R4, #+0]
    316                  res = RES_OK;
   \   0000004A   0020               MOVS     R0,#+0
    317                  break;
   \   0000004C   32E0               B.N      ??disk_ioctl_9
    318              case GET_BLOCK_SIZE :
    319                  command.COMMAND  = ESDHC_CMD9;
   \                     ??disk_ioctl_6:
   \   0000004E   0920               MOVS     R0,#+9
   \   00000050   8DF80000           STRB     R0,[SP, #+0]
    320                  command.TYPE     = ESDHC_TYPE_NORMAL;
   \   00000054   0020               MOVS     R0,#+0
   \   00000056   8DF80100           STRB     R0,[SP, #+1]
    321                  command.ARGUMENT = sdcard_ptr->ADDRESS;
   \   0000005A   5069               LDR      R0,[R2, #+20]
   \   0000005C   0190               STR      R0,[SP, #+4]
    322                  command.READ     = FALSE;
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   8DF80800           STRB     R0,[SP, #+8]
    323                  command.BLOCKS   = 0;
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   0390               STR      R0,[SP, #+12]
    324                  if (ESDHC_OK != hw_sdhc_ioctl (IO_IOCTL_ESDHC_SEND_COMMAND, &command))
   \   00000068   00A9               ADD      R1,SP,#+0
   \   0000006A   0220               MOVS     R0,#+2
   \   0000006C   ........           BL       hw_sdhc_ioctl
   \   00000070   0028               CMP      R0,#+0
   \   00000072   01D0               BEQ.N    ??disk_ioctl_10
    325                      return RES_ERROR;
   \   00000074   0120               MOVS     R0,#+1
   \   00000076   1EE0               B.N      ??disk_ioctl_1
    326          
    327                  if (0 == (command.RESPONSE[3] & 0x00C00000)) //SD V1
   \                     ??disk_ioctl_10:
   \   00000078   0798               LDR      R0,[SP, #+28]
   \   0000007A   10F4400F           TST      R0,#0xC00000
   \   0000007E   0BD1               BNE.N    ??disk_ioctl_11
    328                      *(unsigned long*)buff = ((((command.RESPONSE[2] >> 18) & 0x7F) + 1) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));
   \   00000080   0698               LDR      R0,[SP, #+24]
   \   00000082   C0F38640           UBFX     R0,R0,#+18,#+7
   \   00000086   401C               ADDS     R0,R0,#+1
   \   00000088   0799               LDR      R1,[SP, #+28]
   \   0000008A   090A               LSRS     R1,R1,#+8
   \   0000008C   11F00301           ANDS     R1,R1,#0x3
   \   00000090   491E               SUBS     R1,R1,#+1
   \   00000092   8840               LSLS     R0,R0,R1
   \   00000094   2060               STR      R0,[R4, #+0]
   \   00000096   09E0               B.N      ??disk_ioctl_12
    329                  else //SD V2
    330                      *(unsigned long*)buff = (((command.RESPONSE[2] >> 18) & 0x7F) << (((command.RESPONSE[3] >> 8) & 0x03) - 1));				
   \                     ??disk_ioctl_11:
   \   00000098   0698               LDR      R0,[SP, #+24]
   \   0000009A   C0F38640           UBFX     R0,R0,#+18,#+7
   \   0000009E   0799               LDR      R1,[SP, #+28]
   \   000000A0   090A               LSRS     R1,R1,#+8
   \   000000A2   11F00301           ANDS     R1,R1,#0x3
   \   000000A6   491E               SUBS     R1,R1,#+1
   \   000000A8   8840               LSLS     R0,R0,R1
   \   000000AA   2060               STR      R0,[R4, #+0]
    331                  res = RES_OK;
   \                     ??disk_ioctl_12:
   \   000000AC   0020               MOVS     R0,#+0
    332                  break;
   \   000000AE   01E0               B.N      ??disk_ioctl_9
    333              case CTRL_DISK_TYPE:
    334                  res = sdcard_ptr->CARD_TYPE;
   \                     ??disk_ioctl_7:
   \   000000B0   1078               LDRB     R0,[R2, #+0]
    335              default:
    336                  res = RES_PARERR;
   \                     ??disk_ioctl_8:
   \   000000B2   0420               MOVS     R0,#+4
    337              }
    338              
    339              return res;
   \                     ??disk_ioctl_9:
   \   000000B4   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??disk_ioctl_1:
   \   000000B6   08B0               ADD      SP,SP,#+32
   \   000000B8   10BD               POP      {R4,PC}          ;; return
    340          }
    341          
    342          //=========================================================================
    343          //函数名称：disk_status                                                        
    344          //功能概要：返回数据盘状态                                              
    345          //参数说明：drv：数据盘号
    346          //函数返回：状态                                                        
    347          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    348          uint8 disk_status (uint8 drv)
    349          {
    350              if (drv) return STA_NOINIT;
   \                     disk_status:
   \   00000000   C0B2               UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0028               CMP      R0,#+0
   \   00000004   01D0               BEQ.N    ??disk_status_0
   \   00000006   0120               MOVS     R0,#+1
   \   00000008   01E0               B.N      ??disk_status_1
    351              return Stat;
   \                     ??disk_status_0:
   \   0000000A   ....               LDR.N    R0,??DataTable7
   \   0000000C   0078               LDRB     R0,[R0, #+0]
   \                     ??disk_status_1:
   \   0000000E   7047               BX       LR               ;; return
    352          }
    353          
    354          //=========================================================================
    355          //函数名称：disk_timerproc                                                        
    356          //功能概要：检测SD卡状态                                              
    357          //参数说明：无
    358          //函数返回：无                                                        
    359          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    360          void disk_timerproc (void)
    361          {
    362              uint8 s;	
    363              
    364              Timer++;
   \                     disk_timerproc:
   \   00000000   ....               LDR.N    R0,??DataTable7_3
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   401C               ADDS     R0,R0,#+1
   \   00000006   ....               LDR.N    R1,??DataTable7_3
   \   00000008   0860               STR      R0,[R1, #+0]
    365              s = Stat;
   \   0000000A   ....               LDR.N    R0,??DataTable7
   \   0000000C   0078               LDRB     R0,[R0, #+0]
    366              
    367              if (SDCARD_GPIO_PROTECT == 0)				      
   \   0000000E   ....               LDR.N    R1,??DataTable7_4  ;; 0x400ff110
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   0901               LSLS     R1,R1,#+4
   \   00000014   02D4               BMI.N    ??disk_timerproc_0
    368              {
    369                  s &= ~STA_PROTECT;	           //写使能
   \   00000016   10F0FB00           ANDS     R0,R0,#0xFB
   \   0000001A   01E0               B.N      ??disk_timerproc_1
    370              }
    371              else					          
    372              {
    373                  s |= STA_PROTECT;			   //写保护
   \                     ??disk_timerproc_0:
   \   0000001C   50F00400           ORRS     R0,R0,#0x4
    374              }
    375              if (SDCARD_GPIO_DETECT == 0)	   //卡插入
   \                     ??disk_timerproc_1:
   \   00000020   ....               LDR.N    R1,??DataTable7_4  ;; 0x400ff110
   \   00000022   0968               LDR      R1,[R1, #+0]
   \   00000024   C900               LSLS     R1,R1,#+3
   \   00000026   02D4               BMI.N    ??disk_timerproc_2
    376                  s &= ~STA_NODISK;
   \   00000028   10F0FD00           ANDS     R0,R0,#0xFD
   \   0000002C   01E0               B.N      ??disk_timerproc_3
    377              else					           //卡不存在
    378                  s |= (STA_NODISK | STA_NOINIT);
   \                     ??disk_timerproc_2:
   \   0000002E   50F00300           ORRS     R0,R0,#0x3
    379              
    380              Stat = s;				           //更新卡状态
   \                     ??disk_timerproc_3:
   \   00000032   ....               LDR.N    R1,??DataTable7
   \   00000034   0870               STRB     R0,[R1, #+0]
    381          }
   \   00000036   7047               BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     Stat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   ........           DC32     SDHC_Card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0880D9FF           DC32     0xffd98008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   ........           DC32     Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   10F10F40           DC32     0x400ff110

   Maximum stack usage in bytes:

     Function        .cstack
     --------        -------
     GetCardStat          0
     SetCardStat          0
     disk_initialize     48
     disk_ioctl          40
     disk_read           48
     disk_status          0
     disk_timerproc       0
     disk_write          48


   Section sizes:

     Function/Label  Bytes
     --------------  -----
     Stat               1
     GetCardStat        8
     SetCardStat        8
     Timer              4
     disk_initialize  564
     disk_read        190
     disk_write       268
     disk_ioctl       186
     disk_status       16
     disk_timerproc    56
     ??DataTable7       4
     ??DataTable7_1     4
     ??DataTable7_2     4
     ??DataTable7_3     4
     ??DataTable7_4     4

 
     4 bytes in section .bss
     1 byte  in section .data
 1 316 bytes in section .text
 
 1 316 bytes of CODE memory
     5 bytes of DATA memory

Errors: none
Warnings: 4
