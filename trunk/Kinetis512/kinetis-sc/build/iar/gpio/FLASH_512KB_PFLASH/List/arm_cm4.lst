###############################################################################
#                                                                             #
#                                                       04/Mar/2012  17:39:51 #
# IAR ANSI C/C++ Compiler V6.10.1.22143/W32 EVALUATION for ARM                #
# Copyright 1999-2010 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\arm_cm4.c  #
#    Command line =  "F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\arm_cm4.c #
#                    " -D IAR -D TWR_K60N512 -lCN "F:\My                      #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLASH_512 #
#                    KB_PFLASH\List\" -lB "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLASH_512 #
#                    KB_PFLASH\List\" -o "F:\My Works\K60\Kinetis512\kinetis- #
#                    sc\build\iar\gpio\FLASH_512KB_PFLASH\Obj\" --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I "F:\My     #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\projects\SD-FSL-K60-HwComponents(V1.0)\" -I "F:\My   #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\projects\gpio\" -I "F:\My                            #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\common\" -I "F:\My Works\K60\Kinetis512\kinetis-sc\b #
#                    uild\iar\gpio\..\..\..\src\cpu\" -I "F:\My               #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\cpu\headers\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\uart\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\mcg\" -I "F:\My                              #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\drivers\wdog\" -I "F:\My                             #
#                    Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\..\..\..\ #
#                    src\platforms\" -I "F:\My Works\K60\Kinetis512\kinetis-s #
#                    c\build\iar\gpio\..\" -Ol --use_c++_inline --mfc "F:\My  #
#                    Works\K60\Kinetis512\kinetis-sc\src\cpu\start.c" "F:\My  #
#                    Works\K60\Kinetis512\kinetis-sc\src\cpu\sysinit.c"       #
#                    "F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\vectors.c #
#                    "                                                        #
#    List file    =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLA #
#                    SH_512KB_PFLASH\List\arm_cm4.lst                         #
#    Object file  =  F:\My Works\K60\Kinetis512\kinetis-sc\build\iar\gpio\FLA #
#                    SH_512KB_PFLASH\Obj\arm_cm4.o                            #
#                                                                             #
#                                                                             #
###############################################################################

F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\arm_cm4.c
      1          /*
      2           * File:		arm_cm4.c
      3           * Purpose:		Generic high-level routines for ARM Cortex M4 processors
      4           *
      5           * Notes:
      6           */
      7          
      8          #include "common.h"
      9          
     10          /***********************************************************************/
     11          /*
     12           * Configures the ARM system control register for STOP (deep sleep) mode
     13           * and then executes the WFI instruction to enter the mode.
     14           *
     15           * Parameters:
     16           * none
     17           *
     18           * Note: Might want to change this later to allow for passing in a parameter
     19           *       to optionally set the sleep on exit bit.
     20           */
     21          
     22          void stop (void)
     23          {
     24          	/* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     25          	SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;	
     26          
     27          	/* WFI instruction will start entry into STOP mode */
     28          	asm("WFI");
     29          }
     30          /***********************************************************************/
     31          /*
     32           * Configures the ARM system control register for WAIT (sleep) mode
     33           * and then executes the WFI instruction to enter the mode.
     34           *
     35           * Parameters:
     36           * none
     37           *
     38           * Note: Might want to change this later to allow for passing in a parameter
     39           *       to optionally set the sleep on exit bit.
     40           */
     41          
     42          void wait (void)
     43          {
     44          	/* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
     45          	 * of deep sleep.
     46          	 */
     47          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;	
     48          
     49          	/* WFI instruction will start entry into WAIT mode */
     50          	asm("WFI");
     51          }
     52          /***********************************************************************/
     53          /*
     54           * Change the value of the vector table offset register to the specified value.
     55           *
     56           * Parameters:
     57           * vtor     new value to write to the VTOR
     58           */
     59          
     60          void write_vtor (int vtor)
     61          {
     62                  /* Write the VTOR with the new value */
     63                  SCB_VTOR = vtor;	
     64          }
     65          /***********************************************************************/
     66          /*
     67           * Initialize the NVIC to enable the specified IRQ.
     68           * 
     69           * NOTE: The function only initializes the NVIC to enable a single IRQ. 
     70           * Interrupts will also need to be enabled in the ARM core. This can be 
     71           * done using the EnableInterrupts macro.
     72           *
     73           * Parameters:
     74           * irq    irq number to be enabled (the irq number NOT the vector number)
     75           */
     76          
     77          void enable_irq (int irq)
     78          {
     79              int div;
     80              
     81              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
     82               * used.
     83               */
     84              if (irq > 91)
     85                  printf("\nERR! Invalid IRQ value passed to enable irq function!\n");
     86              
     87              /* Determine which of the NVICISERs corresponds to the irq */
     88              div = irq/32;
     89              
     90              switch (div)
     91              {
     92              	case 0x0:
     93                        NVICICPR0 = 1 << (irq%32);
     94                        NVICISER0 = 1 << (irq%32);
     95                        break;
     96              	case 0x1:
     97                        NVICICPR1 = 1 << (irq%32);
     98                        NVICISER1 = 1 << (irq%32);
     99                        break;
    100              	case 0x2:
    101                        NVICICPR2 = 1 << (irq%32);
    102                        NVICISER2 = 1 << (irq%32);
    103                        break;
    104              }              
    105          }
    106          /***********************************************************************/
    107          /*
    108           * Initialize the NVIC to disable the specified IRQ.
    109           * 
    110           * NOTE: The function only initializes the NVIC to disable a single IRQ. 
    111           * If you want to disable all interrupts, then use the DisableInterrupts
    112           * macro instead. 
    113           *
    114           * Parameters:
    115           * irq    irq number to be disabled (the irq number NOT the vector number)
    116           */
    117          
    118          void disable_irq (int irq)
    119          {
    120              int div;
    121              
    122              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
    123               * used.
    124               */
    125              if (irq > 91)
    126                  printf("\nERR! Invalid IRQ value passed to disable irq function!\n");
    127              
    128              /* Determine which of the NVICICERs corresponds to the irq */
    129              div = irq/32;
    130              
    131              switch (div)
    132              {
    133              	case 0x0:
    134                        NVICICER0 = 1 << (irq%32);
    135                        break;
    136              	case 0x1:
    137                        NVICICER1 = 1 << (irq%32);
    138                        break;
    139              	case 0x2:
    140                        NVICICER2 = 1 << (irq%32);
    141                        break;
    142              }              
    143          }
    144          /***********************************************************************/
    145          /*
    146           * Initialize the NVIC to set specified IRQ priority.
    147           * 
    148           * NOTE: The function only initializes the NVIC to set a single IRQ priority. 
    149           * Interrupts will also need to be enabled in the ARM core. This can be 
    150           * done using the EnableInterrupts macro.
    151           *
    152           * Parameters:
    153           * irq    irq number to be enabled (the irq number NOT the vector number)
    154           * prio   irq priority. 0-15 levels. 0 max priority
    155           */
    156          
    157          void set_irq_priority (int irq, int prio)
    158          {
    159              /*irq priority pointer*/
    160              uint8 *prio_reg;
    161              
    162              /* Make sure that the IRQ is an allowable number. Right now up to 91 is 
    163               * used.
    164               */
    165              if (irq > 91)
    166                  printf("\nERR! Invalid IRQ value passed to priority irq function!\n");
    167          
    168              if (prio > 15)
    169                  printf("\nERR! Invalid priority value passed to priority irq function!\n");
    170              
    171              /* Determine which of the NVICIPx corresponds to the irq */
    172              prio_reg = (uint8 *)(((uint32)&NVICIP0) + irq);
    173              /* Assign priority to IRQ */
    174              *prio_reg = ( (prio&0xF) << (8 - ARM_INTERRUPT_LEVEL_BITS) );             
    175          }
    176          /***********************************************************************/
    177          
F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\start.c
      1          /*
      2           * File:	start.c
      3           * Purpose:	Kinetis start up routines. 
      4           *
      5           * Notes:		
      6           */
      7          
      8          #include "start.h"
      9          #include "common.h"
     10          #include "wdog.h"
     11          #include "sysinit.h"
     12          
     13          /********************************************************************/
     14          /*!
     15           * \brief   Kinetis Start
     16           * \return  None
     17           *
     18           * This function calls all of the needed starup routines and then 
     19           * branches to the main process.
     20           */
     21          void start(void)
     22          {
     23          	/* Disable the watchdog timer */
     24          	wdog_disable();
     25          
     26          	/* Copy any vector or data sections that need to be in RAM */
     27          	common_startup();
     28          
     29          	/* Perform processor initialization */
     30          	sysinit();
     31                  
     32              printf("\n\n");
     33          	
     34          	/* Determine the last cause(s) of reset */
     35          	if (MC_SRSH & MC_SRSH_SW_MASK)
     36          		printf("Software Reset\n");
     37          	if (MC_SRSH & MC_SRSH_LOCKUP_MASK)
     38          		printf("Core Lockup Event Reset\n");
     39          	if (MC_SRSH & MC_SRSH_JTAG_MASK)
     40          		printf("JTAG Reset\n");
     41          	
     42          	if (MC_SRSL & MC_SRSL_POR_MASK)
     43          		printf("Power-on Reset\n");
     44          	if (MC_SRSL & MC_SRSL_PIN_MASK)
     45          		printf("External Pin Reset\n");
     46          	if (MC_SRSL & MC_SRSL_COP_MASK)
     47          		printf("Watchdog(COP) Reset\n");
     48          	if (MC_SRSL & MC_SRSL_LOC_MASK)
     49          		printf("Loss of Clock Reset\n");
     50          	if (MC_SRSL & MC_SRSL_LVD_MASK)
     51          		printf("Low-voltage Detect Reset\n");
     52          	if (MC_SRSL & MC_SRSL_WAKEUP_MASK)
     53          		printf("LLWU Reset\n");	
     54          	
     55          
     56          	/* Determine specific Kinetis device and revision */
     57          	cpu_identify();
     58          	
     59          	/* Jump to main process */
     60          	main();
     61          
     62          	/* No actions to perform after this so wait forever */
     63          	while(1);
     64          }
     65          /********************************************************************/
     66          /*!
     67           * \brief   Kinetis Identify
     68           * \return  None
     69           *
     70           * This is primarly a reporting function that displays information
     71           * about the specific CPU to the default terminal including:
     72           * - Kinetis family
     73           * - package
     74           * - die revision
     75           * - P-flash size
     76           * - Ram size
     77           */
     78          void cpu_identify (void)
     79          {
     80              /* Determine the Kinetis family */
     81              switch((SIM_SDID & SIM_SDID_FAMID(0x7))>>SIM_SDID_FAMID_SHIFT) 
     82              {  
     83              	case 0x0:
     84              		printf("\nK10-");
     85              		break;
     86              	case 0x1:
     87              		printf("\nK20-");
     88              		break;
     89              	case 0x2:
     90              		printf("\nK30-");
     91              		break;
     92              	case 0x3:
     93              		printf("\nK40-");
     94              		break;
     95              	case 0x4:
     96              		printf("\nK60-");
     97              		break;
     98              	case 0x5:
     99              		printf("\nK70-");
    100              		break;
    101              	case 0x6:
    102              		printf("\nK50-");
    103              		break;
    104              	case 0x7:
    105              		printf("\nK53-");
    106              		break;
    107          	default:
    108          		printf("\nUnrecognized Kinetis family device.\n");  
    109          		break;  	
    110              }
    111          
    112              /* Determine the package size */
    113              switch((SIM_SDID & SIM_SDID_PINID(0xF))>>SIM_SDID_PINID_SHIFT) 
    114              {  
    115              	case 0x2:
    116              		printf("32pin       ");
    117              		break;
    118              	case 0x4:
    119              		printf("48pin       ");
    120              		break;
    121              	case 0x5:
    122              		printf("64pin       ");
    123              		break;
    124              	case 0x6:
    125              		printf("80pin       ");
    126              		break;
    127              	case 0x7:
    128              		printf("81pin       ");
    129              		break;
    130              	case 0x8:
    131              		printf("100pin      ");
    132              		break;
    133              	case 0x9:
    134              		printf("104pin      ");
    135              		break;
    136              	case 0xA:
    137              		printf("144pin      ");
    138              		break;
    139              	case 0xC:
    140              		printf("196pin      ");
    141              		break;
    142              	case 0xE:
    143              		printf("256pin      ");
    144              		break;
    145          	default:
    146          		printf("\nUnrecognized Kinetis package code.      ");  
    147          		break;  	
    148              }                
    149          
    150              /* Determine the revision ID */
    151              printf("Silicon rev %d     \n", (SIM_SDID & SIM_SDID_REVID(0xF))>>SIM_SDID_REVID_SHIFT);
    152              
    153              
    154              /* Determine the flash revision */
    155              flash_identify();    
    156              
    157              /* Determine the P-flash size */
    158              switch((SIM_FCFG1 & SIM_FCFG1_FSIZE(0xFF))>>SIM_FCFG1_FSIZE_SHIFT)
    159              {
    160              	case 0x0:
    161              		printf("12 kBytes of P-flash	");
    162              		break;
    163              	case 0x1:
    164              		printf("16 kBytes of P-flash	");
    165              		break;
    166              	case 0x2:
    167              		printf("32 kBytes of P-flash	");
    168              		break;
    169              	case 0x3:
    170              		printf("48 kBytes of P-flash	");
    171              		break;
    172              	case 0x4:
    173              		printf("64 kBytes of P-flash	");
    174              		break;
    175              	case 0x5:
    176              		printf("96 kBytes of P-flash	");
    177              		break;
    178              	case 0x6:
    179              		printf("128 kBytes of P-flash	");
    180              		break;
    181              	case 0x7:
    182              		printf("192 kBytes of P-flash	");
    183              		break;
    184              	case 0x8:
    185              		printf("256 kBytes of P-flash	");
    186              		break;
    187              	case 0x9:
    188              		printf("320 kBytes of P-flash	");
    189              		break;
    190              	case 0xA:
    191              		printf("384 kBytes of P-flash	");
    192              		break;
    193              	case 0xB:
    194              		printf("448 kBytes of P-flash	");
    195              		break;
    196              	case 0xC:
    197              		printf("512 kBytes of P-flash	");
    198              		break;
    199              	case 0xFF:
    200              		printf("Full size P-flash	");
    201              		break;
    202          		default:
    203          			printf("ERR!! Undefined P-flash size\n");  
    204          			break;  		
    205              }
    206          
    207              /* Determine the RAM size */
    208              switch((SIM_SOPT1 & SIM_SOPT1_RAMSIZE(0xF))>>SIM_SOPT1_RAMSIZE_SHIFT)
    209              {
    210              	case 0x5:
    211              		printf(" 32 kBytes of RAM\n\n");
    212              		break;
    213              	case 0x7:
    214              		printf(" 64 kBytes of RAM\n\n");
    215              		break;
    216              	case 0x8:
    217              		printf(" 96 kBytes of RAM\n\n");
    218              		break;
    219              	case 0x9:
    220              		printf(" 128 kBytes of RAM\n\n");
    221              		break;
    222          		default:
    223          			printf(" ERR!! Undefined RAM size\n\n");  
    224          			break;  		
    225              }
    226          }
    227          /********************************************************************/
    228          /*!
    229           * \brief   flash Identify
    230           * \return  None
    231           *
    232           * This is primarly a reporting function that displays information
    233           * about the specific flash parameters and flash version ID for 
    234           * the current device. These parameters are obtained using a special
    235           * flash command call "read resource." The first four bytes returned
    236           * are the flash parameter revision, and the second four bytes are
    237           * the flash version ID.
    238           */
    239          void flash_identify (void)
    240          {
    241              /* Get the flash parameter version */
    242          
    243              /* Write the flash FCCOB registers with the values for a read resource command */
    244              FTFL_FCCOB0 = 0x03;
    245              FTFL_FCCOB1 = 0x00;
    246              FTFL_FCCOB2 = 0x00;
    247              FTFL_FCCOB3 = 0x00;
    248              FTFL_FCCOB8 = 0x01;
    249          
    250              /* All required FCCOBx registers are written, so launch the command */
    251              FTFL_FSTAT = FTFL_FSTAT_CCIF_MASK;
    252          
    253              /* Wait for the command to complete */
    254              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));
    255              
    256              printf("Flash parameter version %d.%d.%d.%d\n",FTFL_FCCOB4,FTFL_FCCOB5,FTFL_FCCOB6,FTFL_FCCOB7);
    257          
    258              /* Get the flash version ID */   
    259          
    260              /* Write the flash FCCOB registers with the values for a read resource command */
    261              FTFL_FCCOB0 = 0x03;
    262              FTFL_FCCOB1 = 0x00;
    263              FTFL_FCCOB2 = 0x00;
    264              FTFL_FCCOB3 = 0x04;
    265              FTFL_FCCOB8 = 0x01;
    266          
    267              /* All required FCCOBx registers are written, so launch the command */
    268              FTFL_FSTAT = FTFL_FSTAT_CCIF_MASK;
    269          
    270              /* Wait for the command to complete */
    271              while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF_MASK));
    272          
    273              printf("Flash version ID %d.%d.%d.%d\n",FTFL_FCCOB4,FTFL_FCCOB5,FTFL_FCCOB6,FTFL_FCCOB7);  
    274          }
    275          /********************************************************************/
    276          
F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\sysinit.c
      1          /*
      2           * File:        sysinit.c
      3           * Purpose:     Kinetis Configuration
      4           *              Initializes processor to a default state
      5           *
      6           * Notes:
      7           *
      8           */
      9          
     10          #include "common.h"
     11          #include "sysinit.h"
     12          #include "uart.h"
     13          
     14          /********************************************************************/
     15          
     16          /* Actual system clock frequency */
     17          int core_clk_khz;
     18          int core_clk_mhz;
     19          int periph_clk_khz;
     20          
     21          /********************************************************************/
     22          void sysinit (void)
     23          {
     24                  /*
     25                   * Enable all of the port clocks. These have to be enabled to configure
     26                   * pin muxing options, so most code will need all of these on anyway.
     27                   */
     28                  SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
     29                                | SIM_SCGC5_PORTB_MASK
     30                                | SIM_SCGC5_PORTC_MASK
     31                                | SIM_SCGC5_PORTD_MASK
     32                                | SIM_SCGC5_PORTE_MASK );
     33          
     34           	/* Ramp up the system clock */
     35          	core_clk_mhz = pll_init(CORE_CLK_MHZ, REF_CLK);
     36          
     37          	/*
     38                   * Use the value obtained from the pll_init function to define variables
     39          	 * for the core clock in kHz and also the peripheral clock. These
     40          	 * variables can be used by other functions that need awareness of the
     41          	 * system frequency.
     42          	 */
     43          	core_clk_khz = core_clk_mhz * 1000;
     44            	periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV2_MASK) >> 24)+ 1);
     45          
     46            	/* For debugging purposes, enable the trace clock and/or FB_CLK so that
     47            	 * we'll be able to monitor clocks and know the PLL is at the frequency
     48            	 * that we expect.
     49            	 */
     50          	trace_clk_init();
     51            	fb_clk_init();
     52          
     53            	/* Enable the pins for the selected UART */
     54                   if (TERM_PORT == UART0_BASE_PTR)
     55                   {
     56                      /* Enable the UART0_TXD function on PTD6 */
     57                      PORTD_PCR6 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     58          
     59                      /* Enable the UART0_RXD function on PTD7 */
     60                      PORTD_PCR7 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     61                   }
     62          
     63                   if (TERM_PORT == UART1_BASE_PTR)
     64            	 {
     65                           /* Enable the UART1_TXD function on PTC4 */
     66            		PORTC_PCR4 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     67          
     68            		/* Enable the UART1_RXD function on PTC3 */
     69            		PORTC_PCR3 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     70            	}
     71          
     72            	if (TERM_PORT == UART2_BASE_PTR)
     73            	{
     74                           /* Enable the UART2_TXD function on PTD3 */
     75            		PORTD_PCR3 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     76          
     77            		/* Enable the UART2_RXD function on PTD2 */
     78            		PORTD_PCR2 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     79            	}
     80          
     81            	if (TERM_PORT == UART3_BASE_PTR)
     82            	{
     83                           /* Enable the UART3_TXD function on PTC17 */
     84            		PORTC_PCR17 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     85          
     86            		/* Enable the UART3_RXD function on PTC16 */
     87            		PORTC_PCR16 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     88            	}
     89            	if (TERM_PORT == UART4_BASE_PTR)
     90            	{
     91                           /* Enable the UART3_TXD function on PTC17 */
     92            		PORTE_PCR24 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     93          
     94            		/* Enable the UART3_RXD function on PTC16 */
     95            		PORTE_PCR25 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
     96            	}
     97            	if (TERM_PORT == UART5_BASE_PTR)
     98            	{
     99                           /* Enable the UART3_TXD function on PTC17 */
    100            		PORTE_PCR8 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
    101          
    102            		/* Enable the UART3_RXD function on PTC16 */
    103            		PORTE_PCR9 = PORT_PCR_MUX(0x3); // UART is alt3 function for this pin
    104            	}
    105            	/* UART0 and UART1 are clocked from the core clock, but all other UARTs are
    106                   * clocked from the peripheral clock. So we have to determine which clock
    107                   * to send to the uart_init function.
    108                   */
    109                  if ((TERM_PORT == UART0_BASE_PTR) | (TERM_PORT == UART1_BASE_PTR))
    110                      uart_init (TERM_PORT, core_clk_khz, TERMINAL_BAUD);
    111                  else
    112            	    uart_init (TERM_PORT, periph_clk_khz, TERMINAL_BAUD);
    113          }
    114          /********************************************************************/
    115          void trace_clk_init(void)
    116          {
    117          	/* Set the trace clock to the core clock frequency */
    118          	SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;
    119          
    120          	/* Enable the TRACE_CLKOUT pin function on PTA6 (alt7 function) */
    121          	PORTA_PCR6 = ( PORT_PCR_MUX(0x7));
    122          }
    123          /********************************************************************/
    124          void fb_clk_init(void)
    125          {
    126          	/* Enable the clock to the FlexBus module */
    127                  SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
    128          
    129           	/* Enable the FB_CLKOUT function on PTC3 (alt5 function) */
    130          	PORTC_PCR3 = ( PORT_PCR_MUX(0x5));
    131          }
    132          /********************************************************************/
F:\My Works\K60\Kinetis512\kinetis-sc\src\cpu\vectors.c
      1          /******************************************************************************
      2          * File:    vectors.c
      3          *
      4          * Purpose: Configure interrupt vector table for Kinetis.
      5          ******************************************************************************/
      6          
      7          #include "vectors.h"
      8          #include "isr.h"
      9          #include "common.h"
     10          
     11          /******************************************************************************
     12          * Vector Table
     13          ******************************************************************************/
     14          typedef void (*vector_entry)(void);
     15          
     16          #if defined(IAR)
     17          	#pragma location = ".intvec"
     18          	const vector_entry  __vector_table[] = //@ ".intvec" =
     19          #elif defined(CW)
     20          	#pragma define_section vectortable ".vectortable" ".vectortable" ".vectortable" far_abs R
     21          	#define VECTOR __declspec(vectortable)
     22          	const VECTOR vector_entry  __vector_table[] = //@ ".intvec" =
     23          #endif
     24          
     25          {
     26             VECTOR_000,           /* Initial SP           */
     27             VECTOR_001,           /* Initial PC           */
     28             VECTOR_002,
     29             VECTOR_003,
     30             VECTOR_004,
     31             VECTOR_005,
     32             VECTOR_006,
     33             VECTOR_007,
     34             VECTOR_008,
     35             VECTOR_009,
     36             VECTOR_010,
     37             VECTOR_011,
     38             VECTOR_012,
     39             VECTOR_013,
     40             VECTOR_014,
     41             VECTOR_015,
     42             VECTOR_016,
     43             VECTOR_017,
     44             VECTOR_018,
     45             VECTOR_019,
     46             VECTOR_020,
     47             VECTOR_021,
     48             VECTOR_022,
     49             VECTOR_023,
     50             VECTOR_024,
     51             VECTOR_025,
     52             VECTOR_026,
     53             VECTOR_027,
     54             VECTOR_028,
     55             VECTOR_029,
     56             VECTOR_030,
     57             VECTOR_031,
     58             VECTOR_032,
     59             VECTOR_033,
     60             VECTOR_034,
     61             VECTOR_035,
     62             VECTOR_036,
     63             VECTOR_037,
     64             VECTOR_038,
     65             VECTOR_039,
     66             VECTOR_040,
     67             VECTOR_041,
     68             VECTOR_042,
     69             VECTOR_043,
     70             VECTOR_044,
     71             VECTOR_045,
     72             VECTOR_046,
     73             VECTOR_047,
     74             VECTOR_048,
     75             VECTOR_049,
     76             VECTOR_050,
     77             VECTOR_051,
     78             VECTOR_052,
     79             VECTOR_053,
     80             VECTOR_054,
     81             VECTOR_055,
     82             VECTOR_056,
     83             VECTOR_057,
     84             VECTOR_058,
     85             VECTOR_059,
     86             VECTOR_060,
     87             VECTOR_061,
     88             VECTOR_062,
     89             VECTOR_063,
     90             VECTOR_064,
     91             VECTOR_065,
     92             VECTOR_066,
     93             VECTOR_067,
     94             VECTOR_068,
     95             VECTOR_069,
     96             VECTOR_070,
     97             VECTOR_071,
     98             VECTOR_072,
     99             VECTOR_073,
    100             VECTOR_074,
    101             VECTOR_075,
    102             VECTOR_076,
    103             VECTOR_077,
    104             VECTOR_078,
    105             VECTOR_079,
    106             VECTOR_080,
    107             VECTOR_081,
    108             VECTOR_082,
    109             VECTOR_083,
    110             VECTOR_084,
    111             VECTOR_085,
    112             VECTOR_086,
    113             VECTOR_087,
    114             VECTOR_088,
    115             VECTOR_089,
    116             VECTOR_090,
    117             VECTOR_091,
    118             VECTOR_092,
    119             VECTOR_093,
    120             VECTOR_094,
    121             VECTOR_095,
    122             VECTOR_096,
    123             VECTOR_097,
    124             VECTOR_098,
    125             VECTOR_099,
    126             VECTOR_100,
    127             VECTOR_101,
    128             VECTOR_102,
    129             VECTOR_103,
    130             VECTOR_104,
    131             VECTOR_105,
    132             VECTOR_106,
    133             VECTOR_107,
    134             VECTOR_108,
    135             VECTOR_109,
    136             VECTOR_110,
    137             VECTOR_111,
    138             VECTOR_112,
    139             VECTOR_113,
    140             VECTOR_114,
    141             VECTOR_115,
    142             VECTOR_116,
    143             VECTOR_117,
    144             VECTOR_118,
    145             VECTOR_119,
    146             VECTOR_120,
    147             VECTOR_121,
    148             VECTOR_122,
    149             VECTOR_123,
    150             VECTOR_124,
    151             VECTOR_125,
    152             VECTOR_126,
    153             VECTOR_127,
    154             VECTOR_128,
    155             VECTOR_129,
    156             VECTOR_130,
    157             VECTOR_131,
    158             VECTOR_132,
    159             VECTOR_133,
    160             VECTOR_134,
    161             VECTOR_135,
    162             VECTOR_136,
    163             VECTOR_137,
    164             VECTOR_138,
    165             VECTOR_139,
    166             VECTOR_140,
    167             VECTOR_141,
    168             VECTOR_142,
    169             VECTOR_143,
    170             VECTOR_144,
    171             VECTOR_145,
    172             VECTOR_146,
    173             VECTOR_147,
    174             VECTOR_148,
    175             VECTOR_149,
    176             VECTOR_150,
    177             VECTOR_151,
    178             VECTOR_152,
    179             VECTOR_153,
    180             VECTOR_154,
    181             VECTOR_155,
    182             VECTOR_156,
    183             VECTOR_157,
    184             VECTOR_158,
    185             VECTOR_159,
    186             VECTOR_160,
    187             VECTOR_161,
    188             VECTOR_162,
    189             VECTOR_163,
    190             VECTOR_164,
    191             VECTOR_165,
    192             VECTOR_166,
    193             VECTOR_167,
    194             VECTOR_168,
    195             VECTOR_169,
    196             VECTOR_170,
    197             VECTOR_171,
    198             VECTOR_172,
    199             VECTOR_173,
    200             VECTOR_174,
    201             VECTOR_175,
    202             VECTOR_176,
    203             VECTOR_177,
    204             VECTOR_178,
    205             VECTOR_179,
    206             VECTOR_180,
    207             VECTOR_181,
    208             VECTOR_182,
    209             VECTOR_183,
    210             VECTOR_184,
    211             VECTOR_185,
    212             VECTOR_186,
    213             VECTOR_187,
    214             VECTOR_188,
    215             VECTOR_189,
    216             VECTOR_190,
    217             VECTOR_191,
    218             VECTOR_192,
    219             VECTOR_193,
    220             VECTOR_194,
    221             VECTOR_195,
    222             VECTOR_196,
    223             VECTOR_197,
    224             VECTOR_198,
    225             VECTOR_199,
    226             VECTOR_200,
    227             VECTOR_201,
    228             VECTOR_202,
    229             VECTOR_203,
    230             VECTOR_204,
    231             VECTOR_205,
    232             VECTOR_206,
    233             VECTOR_207,
    234             VECTOR_208,
    235             VECTOR_209,
    236             VECTOR_210,
    237             VECTOR_211,
    238             VECTOR_212,
    239             VECTOR_213,
    240             VECTOR_214,
    241             VECTOR_215,
    242             VECTOR_216,
    243             VECTOR_217,
    244             VECTOR_218,
    245             VECTOR_219,
    246             VECTOR_220,
    247             VECTOR_221,
    248             VECTOR_222,
    249             VECTOR_223,
    250             VECTOR_224,
    251             VECTOR_225,
    252             VECTOR_226,
    253             VECTOR_227,
    254             VECTOR_228,
    255             VECTOR_229,
    256             VECTOR_230,
    257             VECTOR_231,
    258             VECTOR_232,
    259             VECTOR_233,
    260             VECTOR_234,
    261             VECTOR_235,
    262             VECTOR_236,
    263             VECTOR_237,
    264             VECTOR_238,
    265             VECTOR_239,
    266             VECTOR_240,
    267             VECTOR_241,
    268             VECTOR_242,
    269             VECTOR_243,
    270             VECTOR_244,
    271             VECTOR_245,
    272             VECTOR_246,
    273             VECTOR_247,
    274             VECTOR_248,
    275             VECTOR_249,
    276             VECTOR_250,
    277             VECTOR_251,
    278             VECTOR_252,
    279             VECTOR_253,
    280             VECTOR_254,
    281             VECTOR_255,
    282             CONFIG_1,
    283             CONFIG_2,
    284             CONFIG_3,
    285             CONFIG_4,
    286          
    287          };
    288          // VECTOR_TABLE end
    289          /******************************************************************************
    290          * default_isr(void)
    291          *
    292          * Default ISR definition.
    293          *
    294          * In:  n/a
    295          * Out: n/a
    296          ******************************************************************************/
    297          //#if (defined(CW))
    298          //__declspec(interrupt)
    299          //#endif
    300          
    301          void default_isr(void)
    302          {
    303             #define VECTORNUM                     (*(volatile uint8_t*)(0xE000ED04))
    304          
    305             printf("\n****default_isr entered on vector %d*****\r\n\n",VECTORNUM);
    306             return;
    307          }
    308          /******************************************************************************/
    309          /* End of "vectors.c" */

Errors: 15
Warnings: 25
